<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The CUBE — prototyp (drag overlay fix)</title>
<style>
  :root{ --bg:#e7e7e7; --panel:#fff; --muted:#707070; --accent:#1f7aef; --pad-highlight: rgba(30,140,220,0.06); }
  html,body{height:100%;margin:0;background:var(--bg);color:#222;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;}
  .page{ max-width:1200px; margin:22px auto; padding:12px; box-sizing:border-box;}
  .top-title{ color:#9a9a9a; margin-bottom:10px; font-size:14px; }

  .layout { display:grid; grid-template-columns:720px 1fr; gap:26px; align-items:start; position:relative; }
  .player-wrap{ width:720px; margin:0; }
  .tokens-col{ min-height:720px; padding-top:12px; display:flex; flex-direction:column; gap:12px; align-items:flex-start; }

  /* tokensGrid is only a visual helper now */
  .tokens-grid { width:320px; height:720px; position:relative; border-radius:6px; background:transparent; }

  /* drag layer covers the page so cassettes can move freely */
  #dragLayer {
    position:fixed;
    left:0; top:0; width:100%; height:100%;
    pointer-events:auto;
    z-index:9999; /* on top so we can drag over everything */
  }

  .cassette { position:absolute; width:193px; height:193px; cursor:grab; user-select:none; touch-action:none; transition: transform .12s, box-shadow .12s, outline .12s; background:transparent; }
  .cassette.dragging{ cursor:grabbing; transform:scale(1.02) !important; box-shadow:0 30px 50px rgba(0,0,0,0.18) !important; }
  .cassette svg rect { display:none !important; } /* remove large white rects in embedded svg */
  .cassette.playing { outline:4px solid rgba(40,200,220,0.95); box-shadow:0 30px 60px rgba(30,160,220,0.08); }
  .cassette.queued  { outline:2px dashed rgba(200,200,200,0.12); box-shadow:0 18px 30px rgba(0,0,0,0.06); }

  .hint{ color:#6e6e6e; font-size:13px; }

  /* stable svg button scaling */
  svg#playerSVG .svg-btn { transform-box: fill-box; transform-origin: center center; transition: transform 120ms ease; will-change: transform; }
  svg#playerSVG .svg-btn * { pointer-events:none; }

  /* pad highlight (applied by JS) */
  #playerSVG .pad-highlight-rect { pointer-events:none; fill: var(--pad-highlight); stroke: none; }

  @media (max-width:1000px){ .layout{ grid-template-columns: 1fr; } .player-wrap{ width:100%; } }
</style>
</head>
<body>
  <div class="page">
    <div class="top-title">The cube digital prototype 1</div>

    <div class="layout" id="layout">
      <div class="player-wrap">
        <!-- player SVG (same as before) -->
        <svg id="playerSVG" tabindex="-1" xmlns="http://www.w3.org/2000/svg" width="552" height="673" viewBox="0 0 552 673" preserveAspectRatio="xMidYMid meet">
  <defs>
    <filter id="Rectangle_3"><feOffset input="SourceAlpha"/><feGaussianBlur stdDeviation="1.5" result="blur"/><feFlood result="color"/><feComposite operator="out" in="SourceGraphic" in2="blur"/><feComposite operator="in" in="color"/><feComposite operator="in" in2="SourceGraphic"/></filter>
    <clipPath id="clip-The_cube_digital_prototype_1_1"><rect width="552" height="673"/></clipPath>
  </defs>
  <g id="The_cube_digital_prototype_1_1" clip-path="url(#clip-The_cube_digital_prototype_1_1)">
    <g id="Playyer_body" transform="translate(2 2)" fill="#fff" stroke="#a8a8a8" stroke-width="1">
      <rect width="547" height="671" rx="12" stroke="none"/>
      <rect x="0.5" y="0.5" width="546" height="670" rx="11.5" fill="none"/>
    </g>
    <g id="REader_pad" transform="translate(-291 -175)">
      <g data-type="innerShadowGroup">
        <rect id="Rectangle_3-2" data-name="Rectangle 3" width="535" height="535" rx="8" transform="translate(299 183)" fill="#f7f7f7" opacity="0.997"/>
        <g transform="matrix(1, 0, 0, 1, 291, 175)" filter="url(#Rectangle_3)">
          <rect id="Rectangle_3-3" data-name="Rectangle 3" width="535" height="535" rx="8" transform="translate(8 8)" fill="#fff" opacity="0.997"/>
        </g>
      </g>
      <g id="Ellipse_21" transform="translate(321 204)" fill="none" stroke="#e5e5e5" stroke-width="1">
        <circle id="pad_main_circle" cx="246.5" cy="246.5" r="246.5"/>
        <circle cx="246.5" cy="246.5" r="246" fill="none"/>
      </g>
      <rect id="pad_highlight" class="pad-highlight-rect" x="299" y="183" width="535" height="535" rx="8" style="opacity:0;"></rect>
    </g>
    <text id="Reader_pad-2" transform="translate(26 33)" fill="#707070" font-size="15" font-family="HelveticaNeue, Helvetica Neue"><tspan x="0" y="0">Reader pad</tspan></text>

    <g id="svgControls" transform="translate(0,560)">
      <g id="svgBtn_power" class="svg-btn" transform="translate(36,12)" cursor="pointer" role="button" aria-label="Power">
        <circle cx="24" cy="24" r="22" fill="#fff" stroke="#a8a8a8" stroke-width="1.2" />
        <path d="M24 12v9" stroke="#111" stroke-width="1.6" stroke-linecap="round" fill="none"/>
        <circle cx="24" cy="24" r="10.5" fill="none" stroke="#111" stroke-width="1.1"/>
        <circle id="svg_power_light" cx="52" cy="8" r="4" fill="#dff6df" opacity="1" />
      </g>

      <g id="svgBtn_shuffle" class="svg-btn" transform="translate(320,22)" cursor="pointer" role="button" aria-label="Shuffle">
        <circle cx="14" cy="14" r="14" fill="#fff" stroke="#a8a8a8" stroke-width="1.2" />
        <path d="M6 12 L14 12 C18 12 20 12 22 13.5" stroke="#111" stroke-width="1.1" fill="none" stroke-linecap="round"/>
        <path d="M22 9 L26 5 L22 1" stroke="#111" stroke-width="1.1" fill="none" stroke-linecap="round"/>
      </g>

      <g id="svgBtn_volDown" class="svg-btn" transform="translate(380,22)" cursor="pointer" role="button" aria-label="Volume down">
        <circle cx="14" cy="14" r="14" fill="#fff" stroke="#a8a8a8" stroke-width="1.2" />
        <path d="M6 14h16" stroke="#111" stroke-width="1.4" stroke-linecap="round"/>
      </g>

      <g id="svgBtn_volUp" class="svg-btn" transform="translate(440,22)" cursor="pointer" role="button" aria-label="Volume up">
        <circle cx="14" cy="14" r="14" fill="#fff" stroke="#a8a8a8" stroke-width="1.2" />
        <path d="M14 6v16" stroke="#111" stroke-width="1.4" stroke-linecap="round"/>
        <path d="M6 14h16" stroke="#111" stroke-width="1.4" stroke-linecap="round"/>
      </g>
    </g>

  </g>
</svg>

      </div>

      <div class="tokens-col">
        <div class="hint">Cassette tokens — dra till plattan</div>
        <!-- visual placeholder for tokens area (NOT where draggable items live) -->
        <div id="tokensGrid" class="tokens-grid" aria-hidden="false" style="border:0px solid rgba(0,0,0,0.03);"></div>
      </div>
    </div>
  </div>

  <!-- drag layer: full-page overlay where cassettes will be appended -->
  <div id="dragLayer" aria-hidden="false"></div>

<script>
/* AUDIO: same working URLs */
const AUDIO_FILES = [
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/Armaku_ElektroPunk_Full_Drum_Loop_120_08.wav',
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/Armaku_ElektroPunk_Bass_Loop_11_130_Eb_Min.wav',
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/Armaku_ElektroPunk_Full_Drum_Loop_120_06.wav'
];
const audioEls = AUDIO_FILES.map(()=>null);
async function initAudioSources(){
  for (let i=0;i<AUDIO_FILES.length;i++){
    const url = AUDIO_FILES[i];
    const a = new Audio(); audioEls[i]=a;
    if (!url) continue;
    try{
      const r = await fetch(url);
      if (!r.ok){ console.warn('audio fetch failed', r.status, url); continue; }
      const blob = await r.blob();
      a.src = URL.createObjectURL(blob);
      a.preload='auto';
      a.addEventListener('error', ev=> console.warn('audio error', i+1, ev));
      a.addEventListener('canplay', ()=> console.log('canplay', i+1));
      a.addEventListener('loadedmetadata', ()=> console.log('loadedmetadata', i+1, a.duration));
    }catch(e){
      console.warn('audio init error', e);
      a.src = url; a.preload='auto';
    }
  }
}
initAudioSources();

/* cassette SVG */
const CASSETTE_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="193" height="193" viewBox="0 0 193 193">
  <g id="Group_13" transform="translate(-974 -212)">
    <g id="Group_12">
      <g id="Cassestte" transform="translate(26 70)">
        <g id="Ellipse_23" transform="translate(948 142)" fill="#dbe1e8" stroke="#707070" stroke-width="1">
          <circle cx="96.5" cy="96.5" r="96.5"/><circle cx="96.5" cy="96.5" r="96" fill="none"/>
        </g>
        <g id="Ellipse_22" transform="translate(956 150)" fill="#dbe1e8" stroke="#707070" stroke-width="1" opacity="0.188">
          <circle cx="88.5" cy="88.5" r="88.5"/><circle cx="88.5" cy="88.5" r="88" fill="none"/>
        </g>
        <g id="Ellipse_3" transform="translate(1035 229)" fill="#ebebeb" stroke="#707070" stroke-width="1">
          <circle cx="9.5" cy="9.5" r="9.5"/><circle cx="9.5" cy="9.5" r="9" fill="none"/>
        </g>
        <text id="Track_1" transform="translate(1015 286)" fill="#707070" font-size="20" font-family="HelveticaNeue, Helvetica Neue"><tspan x="0" y="0">Track</tspan></text>
      </g>
    </g>
  </g>
</svg>`;

/* create cassettes but append to dragLayer so they can move across columns */
const tokensGrid = document.getElementById('tokensGrid');
const dragLayer = document.getElementById('dragLayer');
let cassetteState = {}, playQueue = [], currentPlayingId = null;
const positions = [{left:10,top:10},{left:10,top:230},{left:10,top:450}];

for (let i=0;i<3;i++) createCassette('c'+(i+1), i, positions[i]);

function createCassette(id, trackIndex, pos){
  // create wrapper in dragLayer
  const wrapper = document.createElement('div');
  wrapper.className = 'cassette';
  wrapper.dataset.cid = id;
  wrapper.dataset.track = trackIndex;
  // compute initial page coords based on tokensGrid location + pos
  const gridRect = tokensGrid.getBoundingClientRect();
  wrapper.style.left = (gridRect.left + pos.left) + 'px';
  wrapper.style.top = (gridRect.top + pos.top) + 'px';
  wrapper.style.position = 'absolute';
  wrapper.innerHTML = CASSETTE_SVG;
  // remove any big rects inside svg that create white cards
  try { wrapper.querySelectorAll('rect').forEach(r=>r.remove()); } catch(e){}
  dragLayer.appendChild(wrapper);
  cassetteState[id] = { trackIndex, el: wrapper, onPad:false, cached:false, playing:false, queued:false };
  makeDraggable(wrapper);
}

/* robust pad rect */
const playerSVG = document.getElementById('playerSVG');
function getPadRectScreen(){
  try {
    const padCircle = playerSVG.querySelector('#pad_main_circle');
    if (padCircle){
      const r = padCircle.getBoundingClientRect();
      return { left: r.left, top: r.top, width: r.width, height: r.height, centerX: r.left + r.width/2, centerY: r.top + r.height/2 };
    }
    const rectEl = playerSVG.querySelector('#Rectangle_3-2') || playerSVG.querySelector('#Rectangle_3-3') || playerSVG.querySelector('rect[rx="8"]') || playerSVG.querySelector('rect');
    if (rectEl){
      const r2 = rectEl.getBoundingClientRect();
      return { left: r2.left, top: r2.top, width: r2.width, height: r2.height, centerX: r2.left + r2.width/2, centerY: r2.top + r2.height/2 };
    }
    const s = playerSVG.getBoundingClientRect();
    return { left: s.left + 20, top: s.top + 20, width: s.width - 40, height: s.height - 140, centerX: s.left + s.width/2, centerY: s.top + s.height/2 };
  } catch(e){
    const s = playerSVG.getBoundingClientRect();
    return { left: s.left + 20, top: s.top + 20, width: s.width - 40, height: s.height - 140, centerX: s.left + s.width/2, centerY: s.top + s.height/2 };
  }
}

/* draggable: coordinates now in page space (dragLayer) */
function makeDraggable(elem){
  let dragging=false, pid=null, offset={x:0,y:0};
  const id = elem.dataset.cid;

  function down(e){
    e.preventDefault(); dragging=true; pid=e.pointerId;
    try{ elem.setPointerCapture(pid); }catch(e){}
    const r = elem.getBoundingClientRect();
    offset.x = e.clientX - r.left; offset.y = e.clientY - r.top;
    elem.classList.add('dragging');
    if (cassetteState[id].playing) stopCassette(id,true);
  }

  function move(e){
    if(!dragging || e.pointerId!==pid) return;
    let nx = e.clientX - offset.x;
    let ny = e.clientY - offset.y;

    const pad = getPadRectScreen();
    const dx = e.clientX - pad.centerX, dy = e.clientY - pad.centerY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const magnetRadius = Math.max(pad.width, pad.height) * 1.15;
    if (dist < magnetRadius){
      const pull = 0.16 + (1 - dist/magnetRadius)*0.44;
      nx = nx + (pad.centerX - e.clientX)*pull;
      ny = ny + (pad.centerY - e.clientY)*pull;
      elem.style.transform = 'scale(1.02)';
      elem.style.boxShadow = '0 18px 32px rgba(0,0,0,0.20)';
      try { document.getElementById('pad_highlight').style.opacity = 1; } catch(e){}
      console.log('PAD HOVER:', id, 'dist', Math.round(dist));
    } else {
      elem.style.transform = '';
      elem.style.boxShadow = '0 12px 24px rgba(0,0,0,0.12)';
      try { document.getElementById('pad_highlight').style.opacity = 0; } catch(e){}
    }
    // position in page coords
    elem.style.left = nx + 'px';
    elem.style.top = ny + 'px';
  }

  function up(e){
    if(!dragging || e.pointerId!==pid) return;
    dragging=false;
    try{ elem.releasePointerCapture(pid); }catch(e){}
    elem.classList.remove('dragging');
    elem.style.transform='';
    const rect = elem.getBoundingClientRect();
    const centerX = rect.left + rect.width/2, centerY = rect.top + rect.height/2;

    const pad = getPadRectScreen();
    let inside = (centerX >= pad.left && centerX <= pad.left + pad.width && centerY >= pad.top && centerY <= pad.top + pad.height);

    if (!inside) {
      try {
        const hit = document.elementFromPoint(centerX, centerY);
        if (hit){
          if (hit.closest && (hit.closest('#REader_pad') || hit.closest('#Ellipse_21') || hit.closest('#pad_main_circle'))) inside = true;
          else {
            let p = hit;
            while (p && p !== document){
              if (p.id === 'REader_pad' || p.id === 'Ellipse_21' || p.id === 'pad_main_circle') { inside = true; break; }
              p = p.parentNode;
            }
          }
        }
      } catch(err){}
    }

    try { document.getElementById('pad_highlight').style.opacity = 0; } catch(e){}

    if (inside){
      const snapX = pad.centerX - rect.width/2;
      const snapY = pad.centerY - rect.height/2;
      elem.style.left = snapX + 'px';
      elem.style.top = snapY + 'px';
      cassetteState[id].onPad = true;
      console.log('SNAP:', id, 'to pad center');
      if (!cassetteState[id].cached){
        cassetteState[id].cached = true;
        setTimeout(()=>handleDrop(id), 260 + Math.random()*220);
      } else handleDrop(id);
    } else {
      if (cassetteState[id].onPad) {
        cassetteState[id].onPad = false;
        removeFromQueue(id);
        if (cassetteState[id].playing) { stopCassette(id, false); startNextInQueue(); }
      }
    }
    elem.style.boxShadow='';
  }

  elem.addEventListener('pointerdown', down);
  window.addEventListener('pointermove', move);
  window.addEventListener('pointerup', up);
}

/* Playback + queue (same as before) */
function handleDrop(cid){
  const st = cassetteState[cid];
  if (!st) return;
  if (!window._powerOn) { console.log('power off — cached'); return; }
  if (!currentPlayingId) startCassette(cid);
  else if (!st.queued){ st.queued=true; playQueue.push(cid); updateAllUI(); }
}
function startCassette(cid){
  const st = cassetteState[cid];
  if (!st) return;
  const aud = audioEls[st.trackIndex];
  if (!aud || !aud.src) { console.warn('no audio for track', st.trackIndex); return; }
  aud.volume = window._masterVolume || 0.9;
  aud.currentTime = 0;
  const p = aud.play();
  if (p && p.catch) p.catch(e=>console.warn('play rejected', e));
  st.playing=true; st.queued=false; currentPlayingId = cid;
  aud.onended = ()=>{ st.playing=false; currentPlayingId=null; startNextInQueue(); updateAllUI(); };
  updateAllUI();
}
function stopCassette(cid, dueToLift){
  const st = cassetteState[cid]; if (!st) return;
  const aud = audioEls[st.trackIndex]; if (aud && !aud.paused){ try{ aud.pause(); aud.currentTime=0; }catch(e){} }
  st.playing=false; if (currentPlayingId===cid) currentPlayingId=null;
  if (st.queued){ st.queued=false; playQueue = playQueue.filter(x=>x!==cid); }
  updateAllUI();
}
function startNextInQueue(){
  if (currentPlayingId) return;
  if (playQueue.length===0) return;
  const next = window._shuffleOn ? playQueue.splice(Math.floor(Math.random()*playQueue.length),1)[0] : playQueue.shift();
  if (next && cassetteState[next] && cassetteState[next].onPad) startCassette(next);
  updateAllUI();
}
function removeFromQueue(cid){ playQueue = playQueue.filter(x=>x!==cid); if (cassetteState[cid]) cassetteState[cid].queued=false; updateAllUI(); }
function updateAllUI(){ Object.keys(cassetteState).forEach(k=>{ const s = cassetteState[k]; s.el.classList.toggle('playing', !!s.playing); s.el.classList.toggle('queued', !!s.queued); }); }

/* Buttons wiring */
const svgRoot = document.getElementById('playerSVG');
const svgBtn_power = svgRoot.getElementById('svgBtn_power');
const svgBtn_shuffle = svgRoot.getElementById('svgBtn_shuffle');
const svgBtn_volDown = svgRoot.getElementById('svgBtn_volDown');
const svgBtn_volUp = svgRoot.getElementById('svgBtn_volUp');
const svg_power_light = svgRoot.getElementById('svg_power_light');

window._masterVolume = 0.9;
window._powerOn = false;
window._shuffleOn = false;

async function unlockAudioOnce(){ if (window._audioUnlocked) return; window._audioUnlocked = true; for (let a of audioEls) if (a && a.src) { try { await a.play().then(()=>{ a.pause(); a.currentTime=0; }).catch(()=>{}); } catch(e){} } }

function animateSvgBtnGroup(g){ if (!g) return; g.style.transform = 'scale(0.92)'; setTimeout(()=> g.style.transform = '', 150); }

if (svgBtn_power){
  svgBtn_power.addEventListener('click', async (e)=>{
    e.stopPropagation(); animateSvgBtnGroup(svgBtn_power); await unlockAudioOnce();
    window._powerOn = !window._powerOn;
    svgBtn_power.setAttribute('data-pressed', String(window._powerOn));
    svg_power_light.setAttribute('fill', window._powerOn ? '#6ee37b' : '#dff6df');
    if (!window._powerOn){
      Object.keys(cassetteState).forEach(k=>{ stopCassette(k,false); cassetteState[k].queued=false; cassetteState[k].onPad=false; });
      playQueue=[]; currentPlayingId=null;
      // reset positions (put them back to tokensGrid visual start)
      const gridRect = tokensGrid.getBoundingClientRect();
      Object.keys(cassetteState).forEach((k,i)=> { const el = cassetteState[k].el; el.style.left = (gridRect.left + positions[i].left) + 'px'; el.style.top = (gridRect.top + positions[i].top) + 'px'; });
      updateAllUI();
    } else startNextInQueue();
  });
}
if (svgBtn_shuffle){
  svgBtn_shuffle.addEventListener('click', (e)=>{ e.stopPropagation(); animateSvgBtnGroup(svgBtn_shuffle); window._shuffleOn = !window._shuffleOn; svgBtn_shuffle.setAttribute('data-pressed', String(window._shuffleOn)); const circle = svgBtn_shuffle.querySelector('circle'); if (circle) circle.setAttribute('stroke', window._shuffleOn ? '#111' : '#a8a8a8'); });
}
if (svgBtn_volDown){ svgBtn_volDown.addEventListener('click', (e)=>{ e.stopPropagation(); animateSvgBtnGroup(svgBtn_volDown); window._masterVolume = Math.max(0, window._masterVolume - 0.06); audioEls.forEach(a=>{ if (a) a.volume = window._masterVolume; }); }); }
if (svgBtn_volUp){ svgBtn_volUp.addEventListener('click', (e)=>{ e.stopPropagation(); animateSvgBtnGroup(svgBtn_volUp); window._masterVolume = Math.min(1, window._masterVolume + 0.06); audioEls.forEach(a=>{ if (a) a.volume = window._masterVolume; }); }); }

if (svg_power_light) svg_power_light.setAttribute('fill', '#dff6df');
updateAllUI();

console.log('Loaded page with dragLayer overlay.');

/* QUICK DEBUG HELP:
 After reload, in Console run:
 console.log('pad rect:', !!document.getElementById('pad_main_circle'), document.getElementById('pad_main_circle') && document.getElementById('pad_main_circle').getBoundingClientRect());
 console.log('tokensGrid rect:', document.getElementById('tokensGrid').getBoundingClientRect());
 document.querySelectorAll('.cassette').forEach((c,i)=>console.log(i, c.dataset.cid, c.style.left, c.style.top, c.getBoundingClientRect()));
*/
</script>
</body>
</html>
