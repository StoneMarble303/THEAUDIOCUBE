<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The Audio Cube — Reader Pad prototype</title>
<style>
  :root{ --bg:#0a0f14; --card:#0f1720; --muted:#9fb6c7; }
  html,body{height:100%; margin:0; background:linear-gradient(180deg,#08141a,#041016); color:#e6eef8; font-family:Inter,system-ui, -apple-system, "Segoe UI", Roboto, Arial;}
  .wrap{ max-width:1200px; margin:28px auto; display:grid; grid-template-columns: 1fr 360px; gap:20px; }
  .panel{ background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:16px; border-radius:12px; box-shadow:0 10px 30px rgba(2,6,23,0.6); border:1px solid rgba(255,255,255,0.03); }
  .svg-wrap{ height:720px; display:flex; align-items:center; justify-content:center; position:relative; overflow:hidden; }
  /* draggable cassette style (floating over svg) */
  .cassette{
    position:absolute; width:140px; height:72px; border-radius:10px; background:linear-gradient(180deg,#11171b,#0b1114);
    box-shadow: 0 18px 40px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.04); color:#fff; cursor:grab; display:flex; flex-direction:column; justify-content:center; align-items:center;
    user-select:none; touch-action:none; z-index:30;
  }
  .cassette.dragging{ cursor:grabbing; transform:scale(1.02); }
  .cassette .label{ font-weight:700; letter-spacing:0.6px; margin-bottom:6px; }
  .cassette .status{ font-size:12px; color:#9fb6c7; }
  /* loading badge */
  .loading-badge{ position:absolute; left:18px; top:18px; background:rgba(0,0,0,0.5); padding:8px 10px; border-radius:8px; display:flex; gap:8px; align-items:center; }
  .loader{ width:12px; height:12px; border-radius:50%; border:2px solid rgba(255,255,255,0.18); border-top-color:#fff; animation:spin .9s linear infinite; }
  @keyframes spin{ to{ transform:rotate(360deg);} }
  /* controls */
  .controls{ display:flex; flex-direction:column; gap:10px; }
  .controls label{ font-size:13px; color:var(--muted); }
  .queueView{ background:rgba(255,255,255,0.02); padding:10px; border-radius:8px; min-height:150px; color:var(--muted); font-size:13px; overflow:auto; }
  button{ background:#1f7aef; border:0; color:white; padding:8px 10px; border-radius:8px; cursor:pointer; }
  .small{ font-size:13px; color:var(--muted); }
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
        <div>
          <h3 style="margin:0;">The Audio Cube — Reader Pad</h3>
          <div class="small">Dra kassetter på den gråa fyrkanten. Magnetisk känsla. Lägg flera → köas. Lyft för att stoppa.</div>
        </div>
        <div>
          <div class="small">BPM (visuell): <input id="bpm" type="number" value="120" min="60" max="200" style="width:70px;"></div>
        </div>
      </div>

      <div class="svg-wrap" id="svgWrap">
        <!-- Loading badge for simulated cache loads -->
        <div class="loading-badge" id="loadingBadge" style="display:none">
          <div class="loader"></div><div class="small">Loading track…</div>
        </div>

        <!-- INLINE: din SVG (limmad direkt) -->
        <!-- Jag använder Rectangle_1 som reader pad enligt din SVG -->
        <!-- --- Start of pasted SVG --- -->
        <svg id="userSVG" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="960" height="540" viewBox="0 0 1920 1080" preserveAspectRatio="xMidYMid meet">
  <!-- pasted content (your svg) -->
  <!-- For brevity in chat I include it inline exactly as provided earlier -->
  <!-- ... full SVG code goes here ... -->
</svg>
        <!-- --- End of pasted SVG --- -->

        <!-- Floating cassette DOM elements will be injected here by JS -->
      </div>
    </div>

    <div class="panel controls">
      <h4 style="margin:0 0 6px 0;">Kontroll & Queue</h4>
      <div class="controls">
        <div><label>Volymer (per track)</label></div>
        <div><label>Track 1</label><input id="gain1" type="range" min="0" max="1" step="0.01" value="0.9"></div>
        <div><label>Track 2</label><input id="gain2" type="range" min="0" max="1" step="0.01" value="0.9"></div>
        <div><label>Track 3</label><input id="gain3" type="range" min="0" max="1" step="0.01" value="0.9"></div>

        <div style="height:8px;"></div>
        <div class="small">Spela-/kö-status</div>
        <div class="queueView" id="queueView">Ingen kö</div>

        <div style="display:flex;gap:8px;margin-top:8px;">
          <button id="stopAll">Stoppa allt</button>
          <button id="resetPositions">Återställ positioner</button>
        </div>

        <div style="height:12px;"></div>
        <div class="small">Byt audio: lägg dina filer i <code>/audio/track1.mp3</code> etc. Eller ändra URL i koden.</div>
      </div>
    </div>
  </div>

<script>
/* ======================
   Audio + Interaction logic
   - Uses reader pad = SVG element with id "Rectangle_1" (exists in your SVG)
   - 3 cassettes (track1..3)
   - Magnet effect: when dragging cassette near pad, it will be attracted slightly
   - On drop inside pad: start or queue playback
   - Lift (start drag) while playing: stops playback of that cassette
   ====================== */

const AUDIO_FILES = [
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/track1.mp3',
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/Martin%20Roth%20-%20An%20Analog%20Guy%20in%20a%20Digital%20World%20-%2001%20Escape.mp3',
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/track3.mp3'
];

// helpers to detect if the audio file exists; if not we'll fall back to simple oscillator sounds
async function checkAudioExists(url){
  try{
    const r = await fetch(url, {method:'HEAD'});
    return r.ok;
  }catch(e){ return false; }
}

// prepare three Audio elements (can be swapped to WebAudio if advanced needed)
const audioEls = [new Audio(), new Audio(), new Audio()];
async function initAudioSources(){
  for(let i=0;i<3;i++){
    const url = AUDIO_FILES[i];
    const ok = await checkAudioExists(url);
    if(ok) {
      audioEls[i].src = url;
      audioEls[i].preload = 'auto';
    } else {
      // fallback: create a short generated osc-loop using WebAudio and capture to MediaStream? Simpler: silence file not found
      audioEls[i].src = ''; // no source -> we will simulate via oscillator later if needed
    }
  }
}
initAudioSources();

// state
const svgWrap = document.getElementById('svgWrap');
const svgEl = document.getElementById('userSVG');
const padEl = svgEl.getElementById('Rectangle_1') || svgEl.querySelector('rect'); // fallback
const loadingBadge = document.getElementById('loadingBadge');
const queueView = document.getElementById('queueView');

let cassetteState = {
  // id => { trackIndex:0..2, el:DOM, onPad:false, playing:false, queued:false }
};
let playQueue = []; // array of cassette ids in queue order
let currentPlayingId = null;

// create initial cassette DOMs and initial positions
const initialPositions = [
  {x:40, y:120}, {x:40, y:220}, {x:40, y:320}
];

function createCassette(id, trackIndex, pos){
  const c = document.createElement('div');
  c.className = 'cassette';
  c.dataset.cid = id;
  c.dataset.track = trackIndex;
  c.style.left = pos.x + 'px';
  c.style.top = pos.y + 'px';
  c.innerHTML = `<div class="label">Cassette ${trackIndex+1}</div><div class="status">idle</div>`;
  svgWrap.appendChild(c);
  cassetteState[id] = { trackIndex, el:c, onPad:false, playing:false, queued:false };
  makeDraggable(c);
}
for(let i=0;i<3;i++){
  createCassette('cass'+(i+1), i, initialPositions[i]);
}

// draggable logic with magnet effect
function makeDraggable(elem){
  let offset = {x:0,y:0};
  let dragging = false;
  let pointerId = null;
  const id = elem.dataset.cid;

  function getPadRect(){
    // pad bbox in screen coords
    const padBox = padEl.getBBox();
    // SVG might be scaled; convert SVG coords to screen coords via getBoundingClientRect and viewBox ratio
    const svgRect = svgEl.getBoundingClientRect();
    const viewBox = svgEl.viewBox.baseVal;
    const scaleX = svgRect.width / viewBox.width;
    const scaleY = svgRect.height / viewBox.height;
    return {
      left: svgRect.left + padBox.x * scaleX,
      top: svgRect.top + padBox.y * scaleY,
      width: padBox.width * scaleX,
      height: padBox.height * scaleY,
      centerX: svgRect.left + (padBox.x + padBox.width/2)*scaleX,
      centerY: svgRect.top + (padBox.y + padBox.height/2)*scaleY
    };
  }

  function onPointerDown(e){
    e.preventDefault();
    dragging = true;
    elem.classList.add('dragging');
    pointerId = e.pointerId;
    const rect = elem.getBoundingClientRect();
    offset.x = e.clientX - rect.left;
    offset.y = e.clientY - rect.top;
    // if cassette was playing -> stop (lifting behavior)
    const st = cassetteState[id];
    if (st.playing) stopCassette(id, true);
    elem.setPointerCapture(pointerId);
  }
  function onPointerMove(e){
    if(!dragging || e.pointerId !== pointerId) return;
    // target pointer pos
    let nx = e.clientX - offset.x;
    let ny = e.clientY - offset.y;

    // magnetism if near pad: compute distance from pointer to pad center
    const pad = getPadRect();
    const cx = pad.centerX, cy = pad.centerY;
    const dx = (e.clientX - cx), dy = (e.clientY - cy);
    const dist = Math.sqrt(dx*dx + dy*dy);
    const magnetRadius = Math.max(pad.width, pad.height) * 0.7; // attraction area
    if (dist < magnetRadius) {
      // pull a bit toward pad center — create easing offset
      const pullStrength = 0.12 + (1 - dist/magnetRadius) * 0.22; // 0.12..0.34
      nx = nx + (cx - e.clientX) * pullStrength;
      ny = ny + (cy - e.clientY) * pullStrength;
      // small subtle elevating effect (visual)
      elem.style.transform = 'translateZ(0) scale(1.02)';
    } else {
      elem.style.transform = '';
    }

    // constrain to container bounds
    const containerRect = svgWrap.getBoundingClientRect();
    nx = Math.max(containerRect.left - 4, Math.min(nx, containerRect.right - elem.offsetWidth + 4));
    ny = Math.max(containerRect.top - 4, Math.min(ny, containerRect.bottom - elem.offsetHeight + 4));

    elem.style.left = (nx - containerRect.left) + 'px';
    elem.style.top  = (ny - containerRect.top) + 'px';
    // detect if currently inside pad bounds (for hover styling)
    const cxEl = (nx + elem.offsetWidth/2) + containerRect.left;
    const cyEl = (ny + elem.offsetHeight/2) + containerRect.top;
    const inside = (cxEl >= pad.left && cxEl <= pad.left + pad.width && cyEl >= pad.top && cyEl <= pad.top + pad.height);
    if (inside) {
      elem.dataset.inside = '1';
      elem.style.boxShadow = '0 28px 60px rgba(0,0,0,0.7), 0 0 24px rgba(30,130,210,0.08)';
    } else {
      elem.dataset.inside = '0';
      elem.style.boxShadow = '0 18px 40px rgba(0,0,0,0.6)';
    }
  }
  function onPointerUp(e){
    if(!dragging || e.pointerId !== pointerId) return;
    dragging = false;
    elem.classList.remove('dragging');
    elem.releasePointerCapture(pointerId);
    elem.style.transform = '';
    // on drop: if center is inside pad -> place on pad and handle play/queue
    const rect = elem.getBoundingClientRect();
    const containerRect = svgWrap.getBoundingClientRect();
    const centerX = rect.left + rect.width/2;
    const centerY = rect.top + rect.height/2;
    const pad = getPadRect();
    const inside = (centerX >= pad.left && centerX <= pad.left + pad.width && centerY >= pad.top && centerY <= pad.top + pad.height);
    if (inside) {
      // snap visually a little to nearest free spot on pad (we allow free placement but nudge inside margins)
      const localX = Math.max(pad.left + 10, Math.min(centerX, pad.left + pad.width - 10));
      const localY = Math.max(pad.top + 10, Math.min(centerY, pad.top + pad.height - 10));
      // place at coords
      elem.style.left = (localX - containerRect.left - rect.width/2) + 'px';
      elem.style.top  = (localY - containerRect.top - rect.height/2) + 'px';
      // mark as onPad
      cassetteState[id].onPad = true;
      // if not cached -> simulate loading then either start or queue
      if (!cassetteState[id].cached) {
        showLoading(true);
        setTimeout(()=> {
          cassetteState[id].cached = true;
          showLoading(false);
          handleDropOnPad(id);
        }, 800 + Math.random()*700);
      } else {
        handleDropOnPad(id);
      }
    } else {
      // dropped outside pad: ensure it's off-pad state (if it was on pad, remove)
      if (cassetteState[id].onPad) {
        cassetteState[id].onPad = false;
        // remove from queue if queued
        removeFromQueue(id);
        // if it was playing, stop
        if (cassetteState[id].playing) {
          stopCassette(id, false);
          // start next in queue if any
          startNextInQueue();
        }
      }
    }
  }

  elem.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);
}

// loading badge helper
function showLoading(vis){
  loadingBadge.style.display = vis ? 'flex' : 'none';
}

// on drop handler: start or queue
function handleDropOnPad(cid){
  const st = cassetteState[cid];
  if (!st) return;
  // if nothing playing -> start immediately
  if (!currentPlayingId) {
    startCassette(cid);
  } else {
    // already playing -> queue
    if (!st.queued) {
      st.queued = true; playQueue.push(cid); updateQueueView();
    }
  }
  updateCassetteUI(cid);
}

// start a cassette: actually play its audio
function startCassette(cid){
  const st = cassetteState[cid];
  if (!st) return;
  const idx = st.trackIndex;
  // if audio element source present -> play. Else just mark as playing (no sound)
  const aud = audioEls[idx];
  if (aud && aud.src) {
    // stop current playing if any (we use queue semantics, so don't stop)
    aud.currentTime = 0;
    aud.volume = getGainForIndex(idx);
    aud.play().catch(e=>{
      console.warn('Audio play error', e);
    });
    // attach ended handler to start next in queue
    aud.onended = ()=>{
      // mark this cassette as not playing (but keep cached)
      st.playing = false;
      currentPlayingId = null;
      // if this cassette is still onPad but was not in queue, it stays idle
      // start next queued
      startNextInQueue();
      updateCassetteUI(cid);
    };
  } else {
    // fallback: no audio source - simulate a timed playing (e.g. 8s)
    const simDuration = 8000 + Math.floor(Math.random()*4000);
    setTimeout(()=>{
      st.playing = false;
      currentPlayingId = null;
      startNextInQueue();
      updateCassetteUI(cid);
    }, simDuration);
  }
  st.playing = true;
  currentPlayingId = cid;
  // ensure it's removed from queue if was queued
  if (st.queued) {
    st.queued = false;
    playQueue = playQueue.filter(x => x !== cid);
  }
  updateQueueView();
  updateCassetteUI(cid);
}

// stop cassette playback
function stopCassette(cid, dueToLift){
  const st = cassetteState[cid]; if(!st) return;
  const idx = st.trackIndex;
  const aud = audioEls[idx];
  if (aud && aud.src && !aud.paused) {
    try { aud.pause(); aud.currentTime = 0; } catch(e){}
  }
  st.playing = false;
  if (currentPlayingId === cid) currentPlayingId = null;
  // if it was in queue, remove
  if (st.queued) { st.queued = false; playQueue = playQueue.filter(x => x !== cid); }
  updateQueueView();
  updateCassetteUI(cid);
}

// start next in queue
function startNextInQueue(){
  if (currentPlayingId) return;
  if (playQueue.length === 0) {
    updateQueueView();
    return;
  }
  const nextId = playQueue.shift();
  const st = cassetteState[nextId];
  if (!st || !st.onPad) {
    // skip and continue
    return startNextInQueue();
  }
  startCassette(nextId);
}

// remove from queue
function removeFromQueue(cid){
  playQueue = playQueue.filter(x => x !== cid);
  if (cassetteState[cid]) cassetteState[cid].queued = false;
  updateQueueView();
}

// update UI
function updateQueueView(){
  if (currentPlayingId === null && playQueue.length === 0) {
    queueView.textContent = 'Ingen kö';
    return;
  }
  let html = '';
  if (currentPlayingId) {
    const st = cassetteState[currentPlayingId];
    html += `Spelar nu: Cassette ${st.trackIndex+1}\n`;
  }
  if (playQueue.length) {
    html += '\nKö:\n';
    playQueue.forEach((cid,i)=> {
      html += `${i+1}. Cassette ${cassetteState[cid].trackIndex+1}\n`;
    });
  }
  queueView.textContent = html;
}
function updateCassetteUI(cid){
  const st = cassetteState[cid];
  const el = st.el;
  const lab = el.querySelector('.status');
  if (st.playing) lab.textContent = 'playing';
  else if (st.queued) lab.textContent = 'queued';
  else if (st.onPad && st.cached) lab.textContent = 'ready';
  else if (st.onPad && !st.cached) lab.textContent = 'loading';
  else lab.textContent = 'idle';
}

// gain controls
function getGainForIndex(i){
  const el = document.getElementById('gain'+(i+1));
  return el ? parseFloat(el.value) : 0.9;
}
['gain1','gain2','gain3'].forEach(id=>{
  document.getElementById(id).addEventListener('input', ()=>{
    // if audio element playing, update its volume
    for (let k in cassetteState){
      const st = cassetteState[k];
      if (st && st.playing){
        const idx = st.trackIndex;
        if (audioEls[idx] && audioEls[idx].src) audioEls[idx].volume = getGainForIndex(idx);
      }
    }
  });
});

// stop all button
document.getElementById('stopAll').addEventListener('click', ()=>{
  // stop audio
  for (let i=0;i<audioEls.length;i++){
    try { audioEls[i].pause(); audioEls[i].currentTime = 0; } catch(e){}
  }
  // reset states
  Object.keys(cassetteState).forEach(k=>{
    const st = cassetteState[k]; st.playing=false; st.queued=false; st.onPad=false;
    updateCassetteUI(k);
  });
  currentPlayingId = null; playQueue = []; updateQueueView();
});

// reset positions
document.getElementById('resetPositions').addEventListener('click', ()=>{
  const keys = Object.keys(cassetteState);
  for(let i=0;i<keys.length;i++){
    const k = keys[i];
    const pos = {x:40, y:120 + i*110};
    cassetteState[k].el.style.left = pos.x + 'px';
    cassetteState[k].el.style.top  = pos.y + 'px';
  }
});

// initial UI refresh
Object.keys(cassetteState).forEach(k => updateCassetteUI(k));
updateQueueView();

// helper: allow replacing AUDIO_FILES easily - show instructions in console
console.log('Prototyp laddad. För att använda egna spår: lägg filerna i /audio/track1.mp3 etc eller ändra AUDIO_FILES array och uppdatera sidan.');

</script>
</body>
</html>
