<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The CUBE — prototyp (knappar inuti SVG + synliga kassetter)</title>
<style>
  :root{
    --bg:#e7e7e7;
    --panel:#ffffff;
    --muted:#707070;
    --accent:#1f7aef;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#222;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;}
  .page{ max-width:1200px; margin:22px auto; padding:12px; box-sizing:border-box;}
  .top-title{ color:#9a9a9a; margin-bottom:10px; font-size:14px; }

  /* layout */
  .layout { display:grid; grid-template-columns:720px 1fr; gap:26px; align-items:start; }

  .player-wrap{ width:720px; margin:0; }
  .tokens-col{ min-height:720px; padding-top:12px; display:flex; flex-direction:column; gap:12px; align-items:flex-start; }

  /* tokensGrid (where cassettes are placed) */
  .tokens-grid { width:320px; height:720px; position:relative; border-radius:6px; background:transparent; }

  /* cassette */
  .cassette { position:absolute; width:193px; height:193px; cursor:grab; user-select:none; touch-action:none; transition: transform .12s, box-shadow .12s, outline .12s; background:transparent; z-index:40; }
  .cassette.dragging{ cursor:grabbing; transform:scale(1.02); }
  .cassette svg rect { display:none !important; } /* remove any big rects */
  .cassette.playing { outline:4px solid rgba(40,200,220,0.95); box-shadow:0 30px 60px rgba(30,160,220,0.08); }
  .cassette.queued  { outline:2px dashed rgba(200,200,200,0.12); box-shadow:0 18px 30px rgba(0,0,0,0.06); }

  /* subtle helper text */
  .hint{ color:#6e6e6e; font-size:13px; }

  /* remove browser focus ring for svg and children */
  svg#playerSVG, svg#playerSVG * { outline:none !important; -webkit-tap-highlight-color: transparent; }

  /* small responsive */
  @media (max-width:1000px){
    .layout{ grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <div class="page">
    <div class="top-title">The cube digital prototype 1</div>

    <div class="layout">
      <!-- LEFT: player with embedded buttons (inside SVG) -->
      <div class="player-wrap">
        <!-- Player SVG: I injected 4 button groups into this SVG at the white footer area.
             Each group has id: svgBtn_power, svgBtn_shuffle, svgBtn_volDown, svgBtn_volUp.
             They are clickable and animate on click in the JS below. -->
        <svg id="playerSVG" tabindex="-1" xmlns="http://www.w3.org/2000/svg" width="552" height="673" viewBox="0 0 552 673" preserveAspectRatio="xMidYMid meet">
  <defs>
    <filter id="Rectangle_3"><feOffset input="SourceAlpha"/><feGaussianBlur stdDeviation="1.5" result="blur"/><feFlood result="color"/><feComposite operator="out" in="SourceGraphic" in2="blur"/><feComposite operator="in" in="color"/><feComposite operator="in" in2="SourceGraphic"/></filter>
    <clipPath id="clip-The_cube_digital_prototype_1_1"><rect width="552" height="673"/></clipPath>
  </defs>

  <g id="The_cube_digital_prototype_1_1" clip-path="url(#clip-The_cube_digital_prototype_1_1)">
    <!-- outer body -->
    <g id="Playyer_body" transform="translate(2 2)" fill="#fff" stroke="#a8a8a8" stroke-width="1">
      <rect width="547" height="671" rx="12" stroke="none"/>
      <rect x="0.5" y="0.5" width="546" height="670" rx="11.5" fill="none"/>
    </g>

    <!-- reader pad -->
    <g id="REader_pad" transform="translate(-291 -175)">
      <g data-type="innerShadowGroup">
        <rect id="Rectangle_3-2" data-name="Rectangle 3" width="535" height="535" rx="8" transform="translate(299 183)" fill="#f7f7f7" opacity="0.997"/>
        <g transform="matrix(1, 0, 0, 1, 291, 175)" filter="url(#Rectangle_3)">
          <rect id="Rectangle_3-3" data-name="Rectangle 3" width="535" height="535" rx="8" transform="translate(8 8)" fill="#fff" opacity="0.997"/>
        </g>
      </g>
      <g id="Ellipse_21" transform="translate(321 204)" fill="none" stroke="#e5e5e5" stroke-width="1">
        <circle cx="246.5" cy="246.5" r="246.5"/><circle cx="246.5" cy="246.5" r="246" fill="none"/>
      </g>
    </g>

    <text id="Reader_pad-2" transform="translate(26 33)" fill="#707070" font-size="15" font-family="HelveticaNeue, Helvetica Neue"><tspan x="0" y="0">Reader pad</tspan></text>

    <!-- ===========================
         Embedded Controls (placed on the white bottom of the SVG)
         IDs used by JS: svgBtn_power, svgBtn_shuffle, svgBtn_volDown, svgBtn_volUp
         =========================== -->
    <g id="svgControls" transform="translate(0,560)">
      <!-- power button group, placed left -->
      <g id="svgBtn_power" class="svg-btn" transform="translate(36,12)" cursor="pointer">
        <circle cx="24" cy="24" r="22" fill="#fff" stroke="#a8a8a8" stroke-width="1.2" />
        <path d="M24 12v9" stroke="#111" stroke-width="1.6" stroke-linecap="round" fill="none"/>
        <circle cx="24" cy="24" r="10.5" fill="none" stroke="#111" stroke-width="1.1"/>
        <circle id="svg_power_light" cx="52" cy="8" r="4" fill="#dff6df" opacity="1" />
      </g>

      <!-- shuffle -->
      <g id="svgBtn_shuffle" class="svg-btn" transform="translate(320,22)" cursor="pointer">
        <circle cx="14" cy="14" r="14" fill="#fff" stroke="#a8a8a8" stroke-width="1.2" />
        <path d="M6 12 L14 12 C18 12 20 12 22 13.5" stroke="#111" stroke-width="1.1" fill="none" stroke-linecap="round"/>
        <path d="M22 9 L26 5 L22 1" stroke="#111" stroke-width="1.1" fill="none" stroke-linecap="round"/>
      </g>

      <!-- vol down -->
      <g id="svgBtn_volDown" class="svg-btn" transform="translate(380,22)" cursor="pointer">
        <circle cx="14" cy="14" r="14" fill="#fff" stroke="#a8a8a8" stroke-width="1.2" />
        <path d="M6 14h16" stroke="#111" stroke-width="1.4" stroke-linecap="round"/>
      </g>

      <!-- vol up -->
      <g id="svgBtn_volUp" class="svg-btn" transform="translate(440,22)" cursor="pointer">
        <circle cx="14" cy="14" r="14" fill="#fff" stroke="#a8a8a8" stroke-width="1.2" />
        <path d="M14 6v16" stroke="#111" stroke-width="1.4" stroke-linecap="round"/>
        <path d="M6 14h16" stroke="#111" stroke-width="1.4" stroke-linecap="round"/>
      </g>
    </g>

  </g>
</svg>

      </div>

      <!-- RIGHT: tokens column -->
      <div class="tokens-col">
        <div class="hint">Cassette tokens — dra till plattan</div>
        <div id="tokensGrid" class="tokens-grid" aria-hidden="false"></div>
      </div>
    </div>
  </div>

<script>
/* ============================
   Audio files (fetch->blob)
   ============================ */
const AUDIO_FILES = [
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/Armaku_ElektroPunk_Full_Drum_Loop_120_08.wav',
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/Armaku_ElektroPunk_Bass_Loop_11_130_Eb_Min.wav',
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/Armaku_ElektroPunk_Full_Drum_Loop_120_06.wav'
];
const audioEls = AUDIO_FILES.map(()=>null);
async function initAudioSources(){
  for (let i=0;i<AUDIO_FILES.length;i++){
    const url = AUDIO_FILES[i];
    const a = new Audio(); audioEls[i]=a;
    if (!url) continue;
    try{
      const r = await fetch(url);
      if (!r.ok){ console.warn('audio fetch failed', r.status, url); continue; }
      const blob = await r.blob();
      a.src = URL.createObjectURL(blob);
      a.preload='auto';
      a.addEventListener('error', ev=> console.warn('audio error', i+1, ev));
      a.addEventListener('canplay', ()=> console.log('canplay', i+1));
      a.addEventListener('loadedmetadata', ()=> console.log('loadedmetadata', i+1, a.duration));
    }catch(e){
      console.warn('audio init error', e);
      a.src = url; a.preload='auto';
    }
  }
}
initAudioSources();

/* ============================
   Cassette SVG (you provided) as template
   ============================ */
const CASSETTE_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="193" height="193" viewBox="0 0 193 193">
  <g id="Group_13" transform="translate(-974 -212)">
    <g id="Group_12">
      <g id="Cassestte" transform="translate(26 70)">
        <g id="Ellipse_23" transform="translate(948 142)" fill="#dbe1e8" stroke="#707070" stroke-width="1">
          <circle cx="96.5" cy="96.5" r="96.5"/><circle cx="96.5" cy="96.5" r="96" fill="none"/>
        </g>
        <g id="Ellipse_22" transform="translate(956 150)" fill="#dbe1e8" stroke="#707070" stroke-width="1" opacity="0.188">
          <circle cx="88.5" cy="88.5" r="88.5"/><circle cx="88.5" cy="88.5" r="88" fill="none"/>
        </g>
        <g id="Ellipse_3" transform="translate(1035 229)" fill="#ebebeb" stroke="#707070" stroke-width="1">
          <circle cx="9.5" cy="9.5" r="9.5"/><circle cx="9.5" cy="9.5" r="9" fill="none"/>
        </g>
        <text id="Track_1" transform="translate(1015 286)" fill="#707070" font-size="20" font-family="HelveticaNeue, Helvetica Neue"><tspan x="0" y="0">Track</tspan></text>
      </g>
    </g>
  </g>
</svg>`;

/* ============================
   Create visible cassettes in tokensGrid
   ============================ */
const tokensGrid = document.getElementById('tokensGrid');
let cassetteState = {}, playQueue = [], currentPlayingId = null;

/* positions array for initial placement */
const positions = [{left:10,top:10},{left:10,top:230},{left:10,top:450}];
for (let i=0;i<3;i++) createCassette('c'+(i+1), i, positions[i]);

function createCassette(id, trackIndex, pos){
  const wrapper = document.createElement('div');
  wrapper.className = 'cassette';
  wrapper.dataset.cid = id;
  wrapper.dataset.track = trackIndex;
  wrapper.style.left = pos.left + 'px';
  wrapper.style.top = pos.top + 'px';
  wrapper.innerHTML = CASSETTE_SVG;
  // remove background rects if present (guard)
  try { wrapper.querySelectorAll('rect').forEach(r=>r.remove()); } catch(e){}
  tokensGrid.appendChild(wrapper);
  cassetteState[id] = { trackIndex, el: wrapper, onPad:false, cached:false, playing:false, queued:false };
  makeDraggable(wrapper);
}

/* ===== drag/magnet logic (snap to pad) ===== */
const playerSVG = document.getElementById('playerSVG');
const padRectEl = playerSVG.getElementById('Rectangle_3-2') || playerSVG.getElementById('Rectangle_3-3') || playerSVG.querySelector('rect[rx="8"]');

function getPadRectScreen(){
  const padBox = padRectEl.getBBox();
  const svgRect = playerSVG.getBoundingClientRect();
  const viewBox = playerSVG.viewBox.baseVal;
  const scaleX = svgRect.width / viewBox.width;
  const scaleY = svgRect.height / viewBox.height;
  const left = svgRect.left + padBox.x * scaleX;
  const top  = svgRect.top  + padBox.y * scaleY;
  return { left, top, width: padBox.width * scaleX, height: padBox.height * scaleY, centerX:left + (padBox.x + padBox.width/2)*scaleX, centerY: top + (padBox.y + padBox.height/2)*scaleY };
}

function makeDraggable(elem){
  let dragging=false, pid=null, offset={x:0,y:0};
  const id = elem.dataset.cid;

  function down(e){
    e.preventDefault();
    dragging=true; pid=e.pointerId;
    elem.setPointerCapture(pid);
    const r = elem.getBoundingClientRect();
    offset.x = e.clientX - r.left; offset.y = e.clientY - r.top;
    elem.classList.add('dragging');
    if (cassetteState[id].playing) stopCassette(id,true);
  }
  function move(e){
    if(!dragging || e.pointerId!==pid) return;
    let nx = e.clientX - offset.x;
    let ny = e.clientY - offset.y;
    const pad = getPadRectScreen();
    const dx = e.clientX - pad.centerX, dy = e.clientY - pad.centerY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const magnetRadius = Math.max(pad.width, pad.height) * 0.85;
    if (dist < magnetRadius){
      const pull = 0.12 + (1 - dist/magnetRadius)*0.25;
      nx = nx + (pad.centerX - e.clientX)*pull;
      ny = ny + (pad.centerY - e.clientY)*pull;
      elem.style.transform = 'scale(1.02)';
      elem.style.boxShadow = '0 18px 32px rgba(0,0,0,0.20)';
    } else {
      elem.style.transform = '';
      elem.style.boxShadow = '0 12px 24px rgba(0,0,0,0.12)';
    }
    const gridRect = tokensGrid.getBoundingClientRect();
    elem.style.left = Math.max(-10, nx - gridRect.left) + 'px';
    elem.style.top = Math.max(-10, ny - gridRect.top) + 'px';
  }
  function up(e){
    if(!dragging || e.pointerId!==pid) return;
    dragging=false; elem.classList.remove('dragging');
    elem.releasePointerCapture(pid);
    elem.style.transform='';
    const rect = elem.getBoundingClientRect();
    const centerX = rect.left + rect.width/2, centerY = rect.top + rect.height/2;
    const pad = getPadRectScreen();
    const inside = (centerX >= pad.left && centerX <= pad.left + pad.width && centerY >= pad.top && centerY <= pad.top + pad.height);
    if (inside){
      // snap to pad center region
      const container = tokensGrid.getBoundingClientRect();
      const snapX = pad.centerX - rect.width/2;
      const snapY = pad.centerY - rect.height/2;
      elem.style.left = (snapX - tokensGrid.getBoundingClientRect().left) + 'px';
      elem.style.top = (snapY - tokensGrid.getBoundingClientRect().top) + 'px';
      cassetteState[id].onPad = true;
      if (!cassetteState[id].cached){
        cassetteState[id].cached = true;
        setTimeout(()=>handleDrop(id), 400 + Math.random()*400);
      } else handleDrop(id);
    } else {
      if (cassetteState[id].onPad) {
        cassetteState[id].onPad = false;
        removeFromQueue(id);
        if (cassetteState[id].playing) { stopCassette(id, false); startNextInQueue(); }
      }
    }
    elem.style.boxShadow='';
  }

  elem.addEventListener('pointerdown', down);
  window.addEventListener('pointermove', move);
  window.addEventListener('pointerup', up);
}

/* =============== Playback + queue logic =============== */
function handleDrop(cid){
  const st = cassetteState[cid];
  if (!st) return;
  if (!window._powerOn) { console.log('power off — cached'); return; }
  if (!currentPlayingId) startCassette(cid);
  else if (!st.queued){ st.queued=true; playQueue.push(cid); updateAllUI(); }
}

function startCassette(cid){
  const st = cassetteState[cid];
  if (!st) return;
  const idx = st.trackIndex;
  const aud = audioEls[idx];
  if (!aud || !aud.src) { console.warn('no audio for track', idx); return; }
  aud.volume = window._masterVolume || 0.9;
  aud.currentTime = 0;
  const p = aud.play();
  if (p && p.catch) p.catch(e=>console.warn('play rejected', e));
  st.playing=true; st.queued=false; currentPlayingId = cid;
  aud.onended = ()=>{ st.playing=false; currentPlayingId=null; startNextInQueue(); updateAllUI(); };
  updateAllUI();
}

function stopCassette(cid, dueToLift){
  const st = cassetteState[cid]; if (!st) return;
  const aud = audioEls[st.trackIndex]; if (aud && !aud.paused){ try{ aud.pause(); aud.currentTime=0; }catch(e){} }
  st.playing=false; if (currentPlayingId===cid) currentPlayingId=null;
  if (st.queued){ st.queued=false; playQueue = playQueue.filter(x=>x!==cid); }
  updateAllUI();
}

function startNextInQueue(){
  if (currentPlayingId) return;
  if (playQueue.length===0) return;
  const next = window._shuffleOn ? playQueue.splice(Math.floor(Math.random()*playQueue.length),1)[0] : playQueue.shift();
  if (next && cassetteState[next] && cassetteState[next].onPad) startCassette(next);
  updateAllUI();
}

function removeFromQueue(cid){ playQueue = playQueue.filter(x=>x!==cid); if (cassetteState[cid]) cassetteState[cid].queued=false; updateAllUI(); }

function updateAllUI(){
  Object.keys(cassetteState).forEach(k=>{
    const s = cassetteState[k];
    s.el.classList.toggle('playing', !!s.playing);
    s.el.classList.toggle('queued', !!s.queued);
  });
}

/* =============== Controls: embedded SVG buttons wiring =============== */
const svgRoot = document.getElementById('playerSVG');
const svgBtn_power = svgRoot.getElementById('svgBtn_power');
const svgBtn_shuffle = svgRoot.getElementById('svgBtn_shuffle');
const svgBtn_volDown = svgRoot.getElementById('svgBtn_volDown');
const svgBtn_volUp = svgRoot.getElementById('svgBtn_volUp');
const svg_power_light = svgRoot.getElementById('svg_power_light');

window._masterVolume = 0.9;
window._powerOn = false;
window._shuffleOn = false;

async function unlockAudioOnce(){
  if (window._audioUnlocked) return;
  window._audioUnlocked = true;
  for (let a of audioEls) if (a && a.src) {
    try { await a.play().then(()=>{ a.pause(); a.currentTime=0; }).catch(()=>{}); } catch(e){}
  }
}

function animateSvgBtn(g){
  if (!g) return;
  try {
    g.style.transition = 'transform 110ms ease';
    g.style.transform = 'scale(0.92)';
    setTimeout(()=> g.style.transform = '', 150);
  } catch(e){}
}

if (svgBtn_power){
  svgBtn_power.addEventListener('click', async (e)=>{
    e.stopPropagation();
    animateSvgBtn(svgBtn_power);
    await unlockAudioOnce();
    window._powerOn = !window._powerOn;
    svgBtn_power.setAttribute('data-pressed', String(window._powerOn));
    svg_power_light.setAttribute('fill', window._powerOn ? '#6ee37b' : '#dff6df');
    if (!window._powerOn){
      // stop audio & reset positions
      Object.keys(cassetteState).forEach(k=>{ stopCassette(k,false); cassetteState[k].queued=false; cassetteState[k].onPad=false; });
      playQueue=[]; currentPlayingId=null;
      Object.keys(cassetteState).forEach((k,i)=> {
        const el = cassetteState[k].el; el.style.left = positions[i].left + 'px'; el.style.top = positions[i].top + 'px';
      });
      updateAllUI();
    } else {
      startNextInQueue();
    }
  });
}

if (svgBtn_shuffle){
  svgBtn_shuffle.addEventListener('click', (e)=>{
    e.stopPropagation();
    animateSvgBtn(svgBtn_shuffle);
    window._shuffleOn = !window._shuffleOn;
    svgBtn_shuffle.setAttribute('data-pressed', String(window._shuffleOn));
    // subtle visual feedback: change stroke color slightly
    const circle = svgBtn_shuffle.querySelector('circle');
    if (circle) circle.setAttribute('stroke', window._shuffleOn ? '#111' : '#a8a8a8');
  });
}

if (svgBtn_volDown){
  svgBtn_volDown.addEventListener('click', (e)=>{
    e.stopPropagation();
    animateSvgBtn(svgBtn_volDown);
    window._masterVolume = Math.max(0, window._masterVolume - 0.06);
    audioEls.forEach(a=>{ if (a) a.volume = window._masterVolume; });
  });
}

if (svgBtn_volUp){
  svgBtn_volUp.addEventListener('click', (e)=>{
    e.stopPropagation();
    animateSvgBtn(svgBtn_volUp);
    window._masterVolume = Math.min(1, window._masterVolume + 0.06);
    audioEls.forEach(a=>{ if (a) a.volume = window._masterVolume; });
  });
}

/* initial UI state */
svg_power_light.setAttribute('fill', '#dff6df');
updateAllUI();
console.log('Ready — embedded SVG buttons wired, cassettes visible & draggable.');
</script>
</body>
</html>
