<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The CUBE — Music player prototype</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<style>
  /* Fonts: system fallback to avoid external loads in repo preview */
  :root{
    --bg:#000;
    --panel-bg:#f6f6f6;
    --muted:#707070;
    --accent:#1f7aef;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;}
  /* overall layout like your screenshot */
  .stage{
    max-width:1320px;
    margin:28px auto;
    display:grid;
    grid-template-columns: 740px 1fr;
    gap:60px;
    align-items:start;
    padding:16px;
    box-sizing:border-box;
  }

  /* LEFT: player column */
  .player-wrap{ position:relative; }
  .player{
    width:740px;
    background:linear-gradient(180deg,#f7f7f7,#ffffff);
    border-radius:14px;
    border:2px solid rgba(255,255,255,0.06);
    box-shadow:0 8px 30px rgba(0,0,0,0.6);
    padding:18px;
    box-sizing:border-box;
  }

  /* the visible reader pad (inside the large card) matches your SVG sizes */
  .reader-area{
    width:700px;
    height:700px;
    margin:6px auto 12px auto;
    display:flex;align-items:center;justify-content:center;
    position:relative;
  }
  /* we embed your SVG and scale to fit */
  #playerSVG{ width:700px;height:700px; display:block; }

  /* controls row under the reader pad, matching your screenshot */
  .controls-row{
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:14px 26px;
    background:linear-gradient(180deg,#fff,#fafafa);
    border-radius:0 0 14px 14px;
    box-shadow:inset 0 1px 0 rgba(0,0,0,0.03);
    margin-top:6px;
  }
  .controls-left{ display:flex; align-items:center; gap:18px; }
  .ctrl-btn{
    width:54px;height:54px;border-radius:50%; background:linear-gradient(180deg,#f0f0f0,#eaeaea);
    display:flex;align-items:center;justify-content:center;border:1px solid rgba(0,0,0,0.06); box-shadow:0 6px 18px rgba(0,0,0,0.08);
  }
  .ctrl-mid{ display:flex; gap:28px; align-items:center; color:var(--muted); font-size:14px; }
  .volume{ display:flex; align-items:center; gap:8px; }

  /* Right column: tokens */
  .tokens-col{
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:flex-start;
    padding-top:80px;
    gap:36px;
  }

  /* positions for three tokens to match screenshot: two top side-by-side and one centered below */
  .tokens-grid{ width:320px; height:420px; position:relative; }
  .cassette{
    position:absolute;
    width:220px; height:197px;
    cursor:grab;
    touch-action:none;
    user-select:none;
    transition:transform .12s, box-shadow .12s, outline .12s;
    z-index:80;
  }
  .cassette.dragging{ cursor:grabbing; transform:scale(1.02); box-shadow:0 34px 80px rgba(0,0,0,0.7); }
  .cassette svg{ width:100%; height:100%; display:block; }
  /* small text under the control icons like your screenshot */
  .ctrl-labels{ display:flex; gap:38px; justify-content:flex-start; margin-top:8px; color:#d0d0d0; font-size:13px; margin-left:8px; }
  .ctrl-labels div{ display:flex; flex-direction:column; align-items:center; gap:6px; min-width:60px; }
  .ctrl-labels .dot{ width:2px; height:36px; background:#cc3f3f; margin-top:6px; }

  /* queue box in right panel */
  .queue-box{ margin-top:12px; background:rgba(255,255,255,0.02); padding:12px; border-radius:8px; color:#9fb6c7; font-size:13px; min-height:100px; white-space:pre-wrap; }

  /* small responsive */
  @media (max-width:1200px){ .stage{ grid-template-columns: 640px 1fr; } .player{ width:640px; } .reader-area{ width:600px;height:600px;} .tokens-grid{ transform:scale(.95);} }
  @media (max-width:920px){ .stage{ grid-template-columns: 1fr; } .tokens-col{ padding-top:28px; } .player{ width:100%; } .reader-area{ width:92vw;height:92vw; } }

  /* loading badge */
  .loading-badge{ position:absolute; left:20px; top:20px; background:rgba(0,0,0,0.6); color:#fff; padding:8px 10px; border-radius:8px; z-index:200; display:flex; align-items:center; gap:8px; }
  .loader{ width:12px;height:12px;border-radius:50%; border:2px solid rgba(255,255,255,0.18); border-top-color:#fff; animation:spin .9s linear infinite; }
  @keyframes spin{ to{ transform:rotate(360deg); } }

  /* small helper for labels under tokens */
  .token-label{ color:#c0c0c0; font-size:15px; text-align:center; margin-top:8px; }
</style>
</head>
<body>
  <div style="padding-left:34px; padding-top:12px;">
    <div style="color:#cfe7ff; font-weight:600; background:#000; display:inline-block; padding:6px 8px; border-radius:4px;">The CUBE Music player digital prototype</div>
  </div>

  <div class="stage" id="stage">
    <!-- LEFT: player -->
    <div class="player-wrap">
      <div class="player">
        <div class="reader-area" id="readerArea">
          <!-- inlined main 746x923 SVG scaled by CSS above -->
          <!-- (inserted below exactly as provided earlier) -->
          <svg id="playerSVG" xmlns="http://www.w3.org/2000/svg" width="746" height="923" viewBox="0 0 746 923" preserveAspectRatio="xMidYMid meet">
  <defs>
    <filter id="Rectangle_3">
      <feOffset input="SourceAlpha"/>
      <feGaussianBlur stdDeviation="1.5" result="blur"/>
      <feFlood result="color"/>
      <feComposite operator="out" in="SourceGraphic" in2="blur"/>
      <feComposite operator="in" in="color"/>
      <feComposite operator="in" in2="SourceGraphic"/>
    </filter>
    <clipPath id="clip-The_cube_digital_prototype_1">
      <rect width="746" height="923"/>
    </clipPath>
  </defs>
  <g id="The_cube_digital_prototype_1" clip-path="url(#clip-The_cube_digital_prototype_1)">
    <g id="The_cube_reader_pad" transform="translate(-103 -64)">
      <g id="Rectangle_4" transform="translate(837 730.146) rotate(90)" fill="#fff" stroke="#707070" stroke-width="1">
        <rect width="233.354" height="734" rx="31" stroke="none"/>
        <rect x="0.5" y="0.5" width="232.354" height="733" rx="30.5" fill="none"/>
      </g>
      <g id="Rectangle_1" transform="translate(103 64)" fill="#fff" stroke="#707070" stroke-width="1">
        <rect width="734" height="734" rx="12" stroke="none"/>
        <rect x="0.5" y="0.5" width="733" height="733" rx="11.5" fill="none"/>
      </g>
      <g data-type="innerShadowGroup">
        <rect id="Rectangle_3-2" width="717" height="717" rx="11" transform="translate(111 73)" fill="#f7f7f7" opacity="0.997"/>
        <g transform="matrix(1, 0, 0, 1, 103, 64)" filter="url(#Rectangle_3)">
          <rect id="Rectangle_3-3" width="717" height="717" rx="11" transform="translate(8 9)" fill="#fff" opacity="0.997"/>
        </g>
      </g>
      <g id="Ellipse_14" transform="translate(125 86)" fill="#f7f7f7" stroke="#fff" stroke-width="3">
        <circle cx="345.5" cy="345.5" r="345.5" stroke="none"/>
        <circle cx="345.5" cy="345.5" r="344" fill="none"/>
      </g>
      <g id="Ellipse_15" transform="translate(159.5 857.5)" fill="#ebebeb" stroke="#d0d0d0" stroke-width="1">
        <circle cx="27.5" cy="27.5" r="27.5" stroke="none"/>
        <circle cx="27.5" cy="27.5" r="27" fill="none"/>
      </g>
      <text id="Reader_pad" transform="translate(135 105)" fill="#707070" font-size="20" font-family="HelveticaNeue, Helvetica Neue"><tspan x="0" y="0">Reader pad</tspan></text>
      <g id="on-button" transform="translate(166.143 864.037)">
        <path id="Path_1" d="M8.953,6.343a16.91,16.91,0,1,0,23.915,0" transform="translate(0 2.61)" fill="none" stroke="#b9b9b9" stroke-linecap="round" stroke-width="1"/>
        <path id="Path_2" d="M12,12.455V4" transform="translate(8.91 0)" fill="none" stroke="#b9b9b9" stroke-linecap="round" stroke-width="1"/>
      </g>
      <g id="sort-random" transform="translate(561.793 873.97)">
        <path id="Path_5" d="M3,7H4.78c2.152,0,3.228,0,4.1.456A4,4,0,0,1,9.885,8.2c.688.7,1,1.734,1.615,3.8h0c.618.618.927,3.092,1.615,3.8a4,4,0,0,0,1.006.748c.872.456,1.948.456,4.1.456H21m0,0-3-3m3,3-3,3" fill="none" stroke="#222" stroke-width="1"/>
        <path id="Path_6" d="M21.354,6.646l-3-3-.707.707L19.793,6.5H18.2c-1.056,0-1.881,0-2.55.059a4.2,4.2,0,0,0-2.889,1.3l-.056.058c.127.249.238.5.339.754q.056.141.112.291a2.553,2.553,0,0,1,.32-.4,3.5,3.5,0,0,1,.88-.655,3.544,3.544,0,0,1,1.382-.344c.62-.055,1.4-.055,2.486-.055h1.573L17.646,9.646l.707.707,3-3L21.707,7ZM10.3,16.087c-.127-.249-.238-.5-.339-.754q-.056-.141-.112-.291a2.557,2.557,0,0,1-.32.4,3.5,3.5,0,0,1-.88.655,3.544,3.544,0,0,1-1.382.344c-.62.055-1.4.055-2.486.055H3v1H4.8c1.056,0,1.881,0,2.55-.059a4.522,4.522,0,0,0,1.758-.454,4.5,4.5,0,0,0,1.131-.842Z" fill="#222" fill-rule="evenodd"/>
      </g>
      <g id="Group_3" transform="translate(0 129.53)">
        <path id="Path_7" d="M686.981,884.947h17.94" transform="translate(-21.921 -129.477)" fill="none" stroke="#707070" stroke-width="1"/>
        <path id="Path_8" d="M686.981,884.947h17.94" transform="translate(92 -129.477)" fill="none" stroke="#707070" stroke-width="1"/>
        <path id="Path_9" d="M686.981,884.947h17.94" transform="translate(1672.898 59.519) rotate(90)" fill="none" stroke="#707070" stroke-width="1"/>
      </g>
    </g>
  </g>
</svg>
        </div>

        <!-- controls row below the big player, visually like your screenshot -->
        <div class="controls-row" aria-hidden="true">
          <div class="controls-left">
            <div class="ctrl-btn" id="powerBtn" title="On/Off">
              <!-- simple glyph -->
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M12 3v10" stroke="#9aa" stroke-width="2" stroke-linecap="round"/><circle cx="12" cy="16" r="6" stroke="#c7c7c7" stroke-width="1.4" fill="none"/></svg>
            </div>
            <div style="width:36px"></div>
            <div class="ctrl-mid">
              <div style="width:28px"></div>
            </div>
          </div>

          <div style="display:flex;flex-direction:column;align-items:center;gap:6px;">
            <div class="small">Shuffle</div>
            <div style="font-size:20px;color:var(--muted)">⤯</div>
          </div>

          <div style="display:flex;align-items:center;gap:14px;">
            <div style="display:flex;flex-direction:column;align-items:center;">
              <div class="small">–</div>
              <div style="height:28px"></div>
            </div>
            <div style="display:flex;flex-direction:column;align-items:center;">
              <div class="small">+</div>
              <div style="height:28px"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: tokens column -->
    <div class="tokens-col">
      <div class="tokens-grid" id="tokensGrid">
        <!-- three cassette positions (we position them absolute via JS initialPositions) -->
      </div>

      <div style="display:flex;flex-direction:column;align-items:center;margin-top:20px;">
        <div class="token-label">on/off</div>
      </div>

      <div style="margin-top:20px;width:320px;">
        <div class="queue-box" id="queueView">Ingen kö</div>
      </div>
    </div>
  </div>

  <!-- loading badge outside (JS toggles) -->
  <div class="loading-badge" id="loadingBadge" style="display:none; left:60px; top:60px;"><div class="loader"></div><div>Loading…</div></div>

<script>
/* ========== Config: use your raw URLs here ========== */
const AUDIO_FILES = [
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/track1.mp3',
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/Martin%20Roth%20-%20An%20Analog%20Guy%20in%20a%20Digital%20World%20-%2001%20Escape.mp3',
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/track3.mp3'
];
/* ========== setup audio elements ========== */
const audioEls = AUDIO_FILES.map(u => { const a = new Audio(); if(u){ a.src=u; a.preload='auto'; } return a; });

/* ========== state & refs ========== */
const svgWrap = document.getElementById('readerArea');
const playerSVG = document.getElementById('playerSVG');
const padRectEl = playerSVG.getElementById('Rectangle_1'); // reader pad in SVG
const tokensGrid = document.getElementById('tokensGrid');
const loadingBadge = document.getElementById('loadingBadge');
const queueView = document.getElementById('queueView');

let cassetteState = {}; // id -> {trackIndex, el, onPad, cached, playing, queued}
let playQueue = [];
let currentPlayingId = null;

/* ========== small cassette SVG used as visuals ========== */
const CASSETTE_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="220" height="197" viewBox="0 0 220 197">
  <defs><clipPath id="clip-cassette"><rect width="220" height="197"/></clipPath></defs>
  <g clip-path="url(#clip-cassette)">
    <g transform="translate(-935 -138)">
      <g transform="translate(946 138)" fill="#ebebeb" stroke="#707070" stroke-width="1">
        <circle cx="99.5" cy="99.5" r="99.5" stroke="none"/>
        <circle cx="99.5" cy="99.5" r="99" fill="none"/>
      </g>
      <g transform="translate(949 141)" fill="#ebebeb" stroke="#707070" stroke-width="1">
        <circle cx="96.5" cy="96.5" r="96.5" stroke="none"/>
        <circle cx="96.5" cy="96.5" r="96" fill="none"/>
      </g>
      <g transform="translate(1036 228)" fill="#ebebeb" stroke="#707070" stroke-width="1">
        <circle cx="9.5" cy="9.5" r="9.5" stroke="none"/>
        <circle cx="9.5" cy="9.5" r="9" fill="none"/>
      </g>
      <g transform="translate(1095 167)" fill="#ebebeb" stroke="#707070" stroke-width="1">
        <circle cx="5.5" cy="5.5" r="5.5" stroke="none"/>
        <circle cx="5.5" cy="5.5" r="5" fill="none"/>
      </g>
      <text transform="translate(1017 289)" fill="#707070" font-size="20" font-family="HelveticaNeue, Helvetica Neue">Track</text>
    </g>
  </g>
</svg>`;

/* ========== create three cassette DOMs in the right grid ========== */
const initialPositions = [
  {left: 20, top: 8},    // top-left (Track1)
  {left: 180, top: 8},   // top-right (Track2)
  {left: 100, top: 210}  // bottom-center (Track3)
];

for(let i=0;i<3;i++){
  createCassette('cass'+(i+1), i, initialPositions[i]);
}

function createCassette(id, trackIndex, pos){
  const wrapper = document.createElement('div');
  wrapper.className = 'cassette';
  wrapper.dataset.cid = id;
  wrapper.dataset.track = trackIndex;
  wrapper.style.left = pos.left + 'px';
  wrapper.style.top  = pos.top + 'px';
  wrapper.innerHTML = CASSETTE_SVG;
  tokensGrid.appendChild(wrapper);
  cassetteState[id] = { trackIndex, el:wrapper, onPad:false, cached:false, playing:false, queued:false };
  makeDraggable(wrapper);
}

/* ========== draggable + magnet + drop logic (same behaviour as before) ========== */
function getPadRectScreen(){
  const padBox = padRectEl.getBBox();
  const svgRect = playerSVG.getBoundingClientRect();
  const viewBox = playerSVG.viewBox.baseVal;
  const scaleX = svgRect.width / viewBox.width;
  const scaleY = svgRect.height / viewBox.height;
  const left = svgRect.left + padBox.x * scaleX;
  const top  = svgRect.top  + padBox.y * scaleY;
  return { left, top, width: padBox.width * scaleX, height: padBox.height * scaleY, centerX:left + (padBox.x + padBox.width/2)*scaleX, centerY: top + (padBox.y + padBox.height/2)*scaleY };
}

function makeDraggable(elem){
  let dragging=false, pointerId=null, offset={x:0,y:0};
  const id = elem.dataset.cid;

  function onPointerDown(e){
    e.preventDefault();
    dragging=true; pointerId = e.pointerId;
    elem.classList.add('dragging');
    const r = elem.getBoundingClientRect();
    offset.x = e.clientX - r.left; offset.y = e.clientY - r.top;
    // lifting behaviour: if playing -> stop
    const st = cassetteState[id];
    if (st.playing) stopCassette(id, true);
    elem.setPointerCapture(pointerId);
  }
  function onPointerMove(e){
    if(!dragging || e.pointerId !== pointerId) return;
    let nx = e.clientX - offset.x;
    let ny = e.clientY - offset.y;

    const pad = getPadRectScreen();
    const dx = e.clientX - pad.centerX, dy = e.clientY - pad.centerY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const magnetRadius = Math.max(pad.width, pad.height) * 0.75;
    if (dist < magnetRadius){
      const pull = 0.12 + (1 - dist/magnetRadius)*0.25;
      nx = nx + (pad.centerX - e.clientX)*pull;
      ny = ny + (pad.centerY - e.clientY)*pull;
      elem.style.transform = 'scale(1.02)';
    } else elem.style.transform = '';

    // constrain inside viewport of stage for a nicer feel
    const stageRect = document.getElementById('stage').getBoundingClientRect();
    nx = Math.max(stageRect.left - 6, Math.min(nx, stageRect.right - elem.offsetWidth + 6));
    ny = Math.max(stageRect.top - 6, Math.min(ny, stageRect.bottom - elem.offsetHeight + 6));

    elem.style.left = (nx - tokensGrid.getBoundingClientRect().left) + 'px';
    elem.style.top  = (ny - tokensGrid.getBoundingClientRect().top) + 'px';

    // inside pad detection for visual cue (we mark via outline)
    const centerX = nx; const centerY = ny;
    const inside = ( (e.clientX) >= pad.left && (e.clientX) <= pad.left + pad.width && (e.clientY) >= pad.top && (e.clientY) <= pad.top + pad.height );
    if (inside) elem.style.boxShadow = '0 34px 80px rgba(0,0,0,0.7), 0 0 30px rgba(30,140,220,0.06)';
    else elem.style.boxShadow = '0 18px 40px rgba(0,0,0,0.6)';
  }
  function onPointerUp(e){
    if(!dragging || e.pointerId !== pointerId) return;
    dragging=false; elem.classList.remove('dragging'); elem.releasePointerCapture(pointerId); elem.style.transform='';
    const rect = elem.getBoundingClientRect();
    const centerX = rect.left + rect.width/2;
    const centerY = rect.top + rect.height/2;
    const pad = getPadRectScreen();
    const inside = (centerX >= pad.left && centerX <= pad.left + pad.width && centerY >= pad.top && centerY <= pad.top + pad.height);
    if (inside){
      // snap a bit toward center of pad
      const container = tokensGrid.getBoundingClientRect();
      const snapX = Math.max(pad.left + 12, Math.min(centerX, pad.left + pad.width - 12));
      const snapY = Math.max(pad.top + 12, Math.min(centerY, pad.top + pad.height - 12));
      elem.style.left = (snapX - container.left - rect.width/2) + 'px';
      elem.style.top  = (snapY - container.top - rect.height/2) + 'px';
      cassetteState[id].onPad = true;
      if (!cassetteState[id].cached){
        showLoading(true);
        setTimeout(()=>{ cassetteState[id].cached = true; showLoading(false); handleDrop(id); }, 700 + Math.random()*700);
      } else handleDrop(id);
    } else {
      if (cassetteState[id].onPad){
        cassetteState[id].onPad = false;
        removeFromQueue(id);
        if (cassetteState[id].playing){
          stopCassette(id, false);
          startNextInQueue();
        }
      }
    }
  }

  elem.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);
}

/* ========== load UI helpers ========== */
function showLoading(on){ loadingBadge.style.display = on ? 'flex' : 'none'; }

/* ========== drop handling ========== */
function handleDrop(cid){
  const st = cassetteState[cid];
  if (!currentPlayingId) startCassette(cid);
  else {
    if (!st.queued){ st.queued = true; playQueue.push(cid); updateQueueView(); }
  }
  updateCassetteUI(cid);
}

/* ========== start/stop ========== */
function startCassette(cid){
  const st = cassetteState[cid]; if(!st) return;
  const idx = st.trackIndex;
  const aud = audioEls[idx];
  if (aud && aud.src){
    aud.volume = getGainForIndex(idx);
    aud.currentTime = 0;
    aud.play().catch(e=>console.warn('play err',e));
    aud.onended = ()=>{ st.playing=false; currentPlayingId=null; startNextInQueue(); updateCassetteUI(cid); };
  } else {
    setTimeout(()=>{ st.playing=false; currentPlayingId=null; startNextInQueue(); updateCassetteUI(cid); }, 8000 + Math.random()*4000);
  }
  st.playing = true; currentPlayingId = cid;
  if (st.queued){ st.queued=false; playQueue = playQueue.filter(x=>x!==cid); }
  updateQueueView(); updateCassetteUI(cid);
}

function stopCassette(cid, dueToLift){
  const st = cassetteState[cid]; if(!st) return;
  const idx = st.trackIndex; const aud = audioEls[idx];
  if (aud && !aud.paused){ try{ aud.pause(); aud.currentTime=0; }catch(e){} }
  st.playing=false; if (currentPlayingId===cid) currentPlayingId=null;
  if (st.queued){ st.queued=false; playQueue = playQueue.filter(x=>x!==cid); }
  updateQueueView(); updateCassetteUI(cid);
}

/* ========== queue management ========== */
function startNextInQueue(){
  if (currentPlayingId) return;
  while (playQueue.length){
    const next = playQueue.shift();
    const st = cassetteState[next];
    if (st && st.onPad){ startCassette(next); return; }
  }
  updateQueueView();
}
function removeFromQueue(cid){ playQueue = playQueue.filter(x=>x!==cid); if (cassetteState[cid]) cassetteState[cid].queued=false; updateQueueView(); }

/* ========== UI updates ========== */
function updateQueueView(){
  if (!currentPlayingId && playQueue.length===0){ queueView.textContent='Ingen kö'; return; }
  let out='';
  if (currentPlayingId){ out += `Spelar nu: Cassette ${cassetteState[currentPlayingId].trackIndex+1}\n`; }
  if (playQueue.length){ out += '\nKö:\n'; playQueue.forEach((c,i)=> out += `${i+1}. Cassette ${cassetteState[c].trackIndex+1}\n`); }
  queueView.textContent = out;
}
function updateCassetteUI(cid){
  const st = cassetteState[cid]; if(!st) return;
  const el = st.el;
  if (st.playing) el.style.outline = '3px solid rgba(40,200,220,0.9)';
  else if (st.queued) el.style.outline = '2px dashed rgba(200,200,200,0.15)';
  else if (st.onPad && st.cached) el.style.outline = '1px solid rgba(255,255,255,0.03)';
  else el.style.outline = 'none';
}

/* ========== volume controls ========== */
function getGainForIndex(i){ const el = document.getElementById('gain'+(i+1)); return el ? parseFloat(el.value) : 0.9; }
['gain1','gain2','gain3'].forEach(id=>document.getElementById(id).addEventListener('input', ()=>{
  for (let k in cassetteState){
    const st = cassetteState[k];
    if (st && st.playing){
      const idx = st.trackIndex;
      if (audioEls[idx] && audioEls[idx].src) audioEls[idx].volume = getGainForIndex(idx);
    }
  }
}));

/* ========== Stop all & reset positions ========== */
document.getElementById('stopAll').addEventListener('click', ()=>{
  for (let a of audioEls){ try{ a.pause(); a.currentTime=0; }catch(e){} }
  Object.keys(cassetteState).forEach(k => { const s=cassetteState[k]; s.playing=false; s.queued=false; s.onPad=false; updateCassetteUI(k); });
  currentPlayingId=null; playQueue=[]; updateQueueView();
});

document.getElementById('resetPositions').addEventListener('click', ()=>{
  const keys = Object.keys(cassetteState);
  for (let i=0;i<keys.length;i++){
    const k = keys[i];
    cassetteState[k].el.style.left = initialPositions[i].left + 'px';
    cassetteState[k].el.style.top  = initialPositions[i].top + 'px';
  }
  document.getElementById('stopAll').click();
});

/* ========== initial ui refresh ========== */
Object.keys(cassetteState).forEach(k=>updateCassetteUI(k));
updateQueueView();
// ===== AUDIO UNLOCK (lägg till i din script-del) =====
let audioUnlocked = false;
const powerBtn = document.getElementById('powerBtn');

async function unlockAudioOnce(){
  if (audioUnlocked) return;
  audioUnlocked = true;
  // try to play and immediately pause each audio to satisfy browser gesture requirement
  for (let a of audioEls) {
    try {
      // some sources may be empty; skip those
      if (!a.src) continue;
      // play then pause quickly
      await a.play().then(()=> {
        a.pause();
        a.currentTime = 0;
      }).catch(err => {
        console.warn('Unlock play failed (ignored):', err);
      });
    } catch(e){
      console.warn('Unlock error', e);
    }
  }
  console.log('Audio unlocked by user gesture');
  // optional visual feedback
  powerBtn.style.transform = 'scale(0.98)';
  setTimeout(()=> powerBtn.style.transform = '', 120);
}

powerBtn.addEventListener('click', async (e) => {
  await unlockAudioOnce();
});
console.log('CUBE player ready.');
</script>
</body>
</html>
