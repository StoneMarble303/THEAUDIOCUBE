<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>The CUBE — SVG Player (knappar integrerade)</title>
<style>
  :root{ --bg:#000; --muted:#707070; --accent:#1f7aef; }
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;}
  .stage{ max-width:1320px; margin:28px auto; display:grid; grid-template-columns: 740px 1fr; gap:60px; align-items:start; padding:16px; box-sizing:border-box;}
  .player-wrap{ position:relative; }
  .player{ width:740px; background:linear-gradient(180deg,#f7f7f7,#ffffff); border-radius:14px; padding:18px; box-sizing:border-box; }
  .reader-area{ width:700px; height:700px; margin:6px auto 12px auto; display:flex;align-items:center;justify-content:center; position:relative; }
  #playerSVG{ width:700px; height:700px; display:block; }
  /* Controls container where the new SVG buttons will live */
  .controls-row { display:flex; align-items:center; justify-content:space-between; padding:12px 20px; background:transparent; margin-top:6px; }
  .controls-left{ display:flex; align-items:center; gap:18px; }
  .svg-button { cursor:pointer; transition: transform 120ms cubic-bezier(.2,.9,.3,1), filter 120ms; transform-origin:center center; }
  .svg-button:active { transform:scale(0.9); } /* fallback for immediate press */
  /* Visual states */
  .btn-on { filter: none; }
  .btn-off { filter: grayscale(1) brightness(0.9); }
  .btn-active-outline { box-shadow:0 0 0 6px rgba(31,122,239,0.06); border-radius:999px; }
  /* tokens (right column) */
  .tokens-col{ display:flex; flex-direction:column; align-items:center; justify-content:flex-start; padding-top:80px; gap:36px; }
  .tokens-grid{ width:320px; height:420px; position:relative; }
  .cassette{ position:absolute; width:220px; height:197px; cursor:grab; touch-action:none; user-select:none; transition: transform .12s, box-shadow .12s, outline .12s; z-index:80; }
  .cassette.dragging{ cursor:grabbing; transform:scale(1.02); box-shadow:0 34px 80px rgba(0,0,0,0.7); }
  .queue-box{ margin-top:12px; background:rgba(255,255,255,0.02); padding:12px; border-radius:8px; color:#9fb6c7; font-size:13px; min-height:100px; white-space:pre-wrap; }
  .loading-badge{ position:fixed; left:24px; top:24px; background:rgba(0,0,0,0.6); color:#fff; padding:8px 10px; border-radius:8px; z-index:999; display:none; align-items:center; gap:8px; }
  .loader{ width:12px;height:12px;border-radius:50%; border:2px solid rgba(255,255,255,0.18); border-top-color:#fff; animation:spin .9s linear infinite; }
  @keyframes spin{ to{ transform:rotate(360deg);} }
  /* responsive */
  @media (max-width:1000px){ .stage{ grid-template-columns:1fr; } .player{ width:100%; } .reader-area{ width:92vw; height:92vw; } .tokens-grid{ transform:scale(.95);} }
</style>
</head>
<body>
  <div style="padding-left:34px; padding-top:12px;">
    <div style="color:#cfe7ff; font-weight:600; display:inline-block; padding:6px 8px; border-radius:4px;">The CUBE Music player digital prototype</div>
  </div>

  <div class="stage" id="stage">
    <div class="player-wrap">
      <div class="player">
        <div class="reader-area" id="readerArea">
          <!-- Main big player SVG (inlined) -->
          <svg id="playerSVG" xmlns="http://www.w3.org/2000/svg" width="746" height="923" viewBox="0 0 746 923" preserveAspectRatio="xMidYMid meet">
  <defs>
    <filter id="Rectangle_3"><feOffset input="SourceAlpha"/><feGaussianBlur stdDeviation="1.5" result="blur"/><feFlood result="color"/><feComposite operator="out" in="SourceGraphic" in2="blur"/><feComposite operator="in" in="color"/><feComposite operator="in" in2="SourceGraphic"/></filter>
    <clipPath id="clip-The_cube_digital_prototype_1"><rect width="746" height="923"/></clipPath>
  </defs>
  <g id="The_cube_digital_prototype_1" clip-path="url(#clip-The_cube_digital_prototype_1)">
    <g id="The_cube_reader_pad" transform="translate(-103 -64)">
      <g id="Rectangle_4" transform="translate(837 730.146) rotate(90)" fill="#fff" stroke="#707070" stroke-width="1">
        <rect width="233.354" height="734" rx="31" stroke="none"/><rect x="0.5" y="0.5" width="232.354" height="733" rx="30.5" fill="none"/>
      </g>
      <g id="Rectangle_1" transform="translate(103 64)" fill="#fff" stroke="#707070" stroke-width="1">
        <rect width="734" height="734" rx="12" stroke="none"/><rect x="0.5" y="0.5" width="733" height="733" rx="11.5" fill="none"/>
      </g>
      <g data-type="innerShadowGroup">
        <rect id="Rectangle_3-2" width="717" height="717" rx="11" transform="translate(111 73)" fill="#f7f7f7" opacity="0.997"/>
        <g transform="matrix(1, 0, 0, 1, 103, 64)" filter="url(#Rectangle_3)"><rect id="Rectangle_3-3" width="717" height="717" rx="11" transform="translate(8 9)" fill="#fff" opacity="0.997"/></g>
      </g>
      <g id="Ellipse_14" transform="translate(125 86)" fill="#f7f7f7" stroke="#fff" stroke-width="3"><circle cx="345.5" cy="345.5" r="345.5" stroke="none"/><circle cx="345.5" cy="345.5" r="344" fill="none"/></g>
      <g id="Ellipse_15" transform="translate(159.5 857.5)" fill="#ebebeb" stroke="#d0d0d0" stroke-width="1"><circle cx="27.5" cy="27.5" r="27.5" stroke="none"/><circle cx="27.5" cy="27.5" r="27" fill="none"/></g>
      <text id="Reader_pad" transform="translate(135 105)" fill="#707070" font-size="20" font-family="HelveticaNeue, Helvetica Neue"><tspan x="0" y="0">Reader pad</tspan></text>
      <g id="on-button" transform="translate(166.143 864.037)"><path id="Path_1" d="M8.953,6.343a16.91,16.91,0,1,0,23.915,0" transform="translate(0 2.61)" fill="none" stroke="#b9b9b9" stroke-linecap="round" stroke-width="1"/><path id="Path_2" d="M12,12.455V4" transform="translate(8.91 0)" fill="none" stroke="#b9b9b9" stroke-linecap="round" stroke-width="1"/></g>
      <g id="sort-random" transform="translate(561.793 873.97)"><path id="Path_5" d="M3,7H4.78c2.152,0,3.228,0,4.1.456A4,4,0,0,1,9.885,8.2c.688.7,1,1.734,1.615,3.8h0c.618.618.927,3.092,1.615,3.8a4,4,0,0,0,1.006.748c.872.456,1.948.456,4.1.456H21m0,0-3-3m3,3-3,3" fill="none" stroke="#222" stroke-width="1"/><path id="Path_6" d="M21.354,6.646l-3-3-.707.707L19.793,6.5H18.2c-1.056,0-1.881,0-2.55.059a4.2,4.2,0,0,0-2.889,1.3l-.056.058c.127.249.238.5.339.754q.056.141.112.291a2.553,2.553,0,0,1,.32-.4,3.5,3.5,0,0,1,.88-.655,3.544,3.544,0,0,1,1.382-.344c.62-.055,1.4-.055,2.486-.055h1.573L17.646,9.646l.707.707,3-3L21.707,7ZM10.3,16.087c-.127-.249-.238-.5-.339-.754q-.056-.141-.112-.291a2.557,2.557,0,0,1-.32.4,3.5,3.5,0,0,1-.88.655,3.544,3.544,0,0,1-1.382.344c-.62.055-1.4.055-2.486.055H3v1H4.8c1.056,0,1.881,0,2.55-.059a4.522,4.522,0,0,0,1.758-.454,4.5,4.5,0,0,0,1.131-.842Z" fill="#222" fill-rule="evenodd"/></g>
    </g>
  </g>
</svg>
        </div>

        <!-- new controls row: uses provided small SVGs placed inline -->
        <div class="controls-row" id="controlsRow">
          <div class="controls-left">
            <!-- On/Off (we use the small provided on/off SVG graphic inline) -->
            <div id="powerBtnSvg" class="svg-button" data-action="power" title="Power">
              <!-- Provided On/Off SVG (rotated rectangle as visual) -->
              <svg xmlns="http://www.w3.org/2000/svg" width="54" height="54" viewBox="0 0 120.431 547.58" style="width:54px;height:54px;">
                <g transform="rotate(90 60 60)" fill="#fff" stroke="#707070" stroke-width="1">
                  <rect width="120.431" height="547.58" rx="6" stroke="none"></rect>
                  <rect x="0.5" y="0.5" width="119.431" height="546.58" rx="5.5" fill="none"></rect>
                </g>
              </svg>
            </div>

            <!-- Shuffle -->
            <div id="shuffleBtn" class="svg-button" data-action="shuffle" title="Shuffle" style="width:40px;height:40px;">
              <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40">
                <g transform="translate(-514 -770)">
                  <g transform="translate(514 770)" fill="#fff" stroke="#707070" stroke-width="1"><circle cx="20" cy="20" r="20"/><circle cx="20" cy="20" r="19.5" fill="none"/></g>
                  <g transform="translate(526.718 783.202)"><path d="M3,7H4.328a6.849,6.849,0,0,1,3.058.34,2.984,2.984,0,0,1,.75.558,6.849,6.849,0,0,1,1.2,2.831h0a6.85,6.85,0,0,0,1.2,2.831,2.985,2.985,0,0,0,.75.558,6.85,6.85,0,0,0,3.058.34h2.074m0,0L14.19,12.222m2.238,2.238L14.19,16.7" transform="translate(-3 -4.498)" fill="none" stroke="#222" stroke-width="1"/><path d="M16.692,5.885,14.454,3.646l-.528.528,1.6,1.6H14.337c-.788,0-1.4,0-1.9.044a3.132,3.132,0,0,0-2.155.967l-.041.043c.095.186.178.374.253.563q.042.106.083.217a1.905,1.905,0,0,1,.239-.3,2.611,2.611,0,0,1,.656-.488A2.644,2.644,0,0,1,12.5,6.562c.462-.041,1.045-.041,1.855-.041h1.173l-1.6,1.6.528.528,2.238-2.238.264-.264ZM8.445,12.927c-.095-.186-.178-.374-.253-.563q-.042-.106-.083-.217a1.907,1.907,0,0,1-.239.3,2.613,2.613,0,0,1-.657.488,2.644,2.644,0,0,1-1.031.257c-.462.041-1.045.041-1.855.041H3v.746H4.346c.788,0,1.4,0,1.9-.044A3.373,3.373,0,0,0,7.559,13.6a3.356,3.356,0,0,0,.844-.628Z" transform="translate(-3 -3.646)" fill="#222" fill-rule="evenodd"/></g>
                </g>
              </svg>
            </div>

            <!-- Vol - -->
            <div id="volDownBtn" class="svg-button" data-action="vol-down" title="Volume down" style="width:40px;height:40px;">
              <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40">
                <g transform="translate(-627 -770)"><g transform="translate(627 770)" fill="#fff" stroke="#707070" stroke-width="1"><circle cx="20" cy="20" r="20"/><circle cx="20" cy="20" r="19.5" fill="none"/></g><path d="M685.981,884.947h14.384" transform="translate(-45.981 -94.947)" fill="none" stroke="#000" stroke-width="1"/></g>
              </svg>
            </div>

            <!-- Vol + -->
            <div id="volUpBtn" class="svg-button" data-action="vol-up" title="Volume up" style="width:40px;height:40px;">
              <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40">
                <g transform="translate(-693 -770)"><g transform="translate(693 770)" fill="#fff" stroke="#707070" stroke-width="1"><circle cx="20" cy="20" r="20"/><circle cx="20" cy="20" r="19.5" fill="none"/></g><g><path d="M686.981,884.947h13.384" transform="translate(19.007 -94.947)" fill="none" stroke="#000" stroke-width="1"/><path d="M0,0H13.384" transform="translate(712.68 783.308) rotate(90)" fill="none" stroke="#000" stroke-width="1"/></g></g>
              </svg>
            </div>
          </div>

          <!-- right side: small text or empty -->
          <div style="display:flex;align-items:center;">
            <div class="small" id="powerStateLabel" style="color:#9fb6c7">Power: Off</div>
          </div>
        </div>

      </div>
    </div>

    <div class="tokens-col">
      <div class="tokens-grid" id="tokensGrid"></div>
      <div style="margin-top:20px;width:320px;">
        <div class="queue-box" id="queueView">Ingen kö</div>
      </div>
    </div>
  </div>

  <div class="loading-badge" id="loadingBadge"><div class="loader"></div><div>Loading…</div></div>

<script>
/* ============================
   Konfiguration & Audio setup
   ============================ */
// ===== robust audio init (ersätt tidigare audioEls-setup med detta) =====
const AUDIO_FILES = [
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/Armaku_ElektroPunk_Bass_Loop_11_130_Eb_Min.wav,
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/Armaku_ElektroPunk_Full_Drum_Loop_120_06.wav',
  'https://raw.githubusercontent.com/StoneMarble303/THEAUDIOCUBE/main/audio/Armaku_ElektroPunk_Full_Drum_Loop_120_08.wav'
];

const audioEls = [null, null, null];

async function initAudioSources(){
  for (let i = 0; i < AUDIO_FILES.length; i++){
    const url = AUDIO_FILES[i];
    audioEls[i] = new Audio(); // placeholder element

    console.log('[audio init] checking url', i, url);
    try{
      // HEAD check first (some hosts may not support HEAD, then we fall back to GET)
      let ok = false;
      try {
        const head = await fetch(url, { method: 'HEAD' });
        ok = head.ok;
        console.log(`[audio init] HEAD status for track ${i+1}:`, head.status);
      } catch(headErr){
        console.warn(`[audio init] HEAD failed for ${url} — trying GET`, headErr);
      }

      // If HEAD didn't return ok, try a lightweight GET for sanity
      if(!ok){
        const r = await fetch(url, { method: 'GET' });
        if (!r.ok) {
          console.warn(`[audio init] GET returned ${r.status} for ${url}`);
          continue; // leave audioEls[i] as empty audio (no src)
        }
        // if GET ok, create blob URL to avoid MIME/CORS surprises
        const blob = await r.blob();
        const objectUrl = URL.createObjectURL(blob);
        audioEls[i].src = objectUrl;
        audioEls[i].preload = 'auto';
        console.log(`[audio init] loaded track ${i+1} via blob URL`);
      } else {
        // HEAD said ok: we still fetch blob for most robust playback (avoids some CORS/content-type problems)
        try {
          const r2 = await fetch(url);
          if (!r2.ok) { console.warn(`[audio init] fetch (after HEAD) returned ${r2.status} for ${url}`); continue; }
          const blob2 = await r2.blob();
          const objectUrl2 = URL.createObjectURL(blob2);
          audioEls[i].src = objectUrl2;
          audioEls[i].preload = 'auto';
          console.log(`[audio init] loaded track ${i+1} via blob (HEAD ok)`);
        } catch(fetchErr){
          console.warn(`[audio init] fetch after HEAD failed for ${url}`, fetchErr);
          // last resort: set direct src (may be blocked by CORS), but set it to try
          audioEls[i].src = url;
          audioEls[i].preload = 'auto';
        }
      }
    } catch(err){
      console.error('[audio init] unexpected error for', url, err);
      // keep audio element but without src
    }

    // debug: if audio has no src, mark it
    if (!audioEls[i].src) {
      console.warn(`[audio init] WARNING: track ${i+1} has no usable src (check URL/CORS).`);
    }
  }
}
initAudioSources();
/* ============================
   State + refs
   ============================ */
const playerSVG = document.getElementById('playerSVG');
const padRectEl = playerSVG.getElementById('Rectangle_1');
const tokensGrid = document.getElementById('tokensGrid');
const loadingBadge = document.getElementById('loadingBadge');
const queueView = document.getElementById('queueView');
const powerBtnSvg = document.getElementById('powerBtnSvg');
const shuffleBtn = document.getElementById('shuffleBtn');
const volDownBtn = document.getElementById('volDownBtn');
const volUpBtn = document.getElementById('volUpBtn');
const powerStateLabel = document.getElementById('powerStateLabel');

let cassetteState = {};
let playQueue = [];
let currentPlayingId = null;
let masterVolume = 0.95; // 0..1
let audioUnlocked = false;
let powerOn = false;
let shuffleOn = false;

/* ============================
   Cassette visual SVG (you gave this earlier)
   ============================ */
const CASSETTE_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="220" height="197" viewBox="0 0 220 197">
  <defs><clipPath id="clip-cassette"><rect width="220" height="197"/></clipPath></defs>
  <g clip-path="url(#clip-cassette)">
    <g transform="translate(-935 -138)">
      <g transform="translate(946 138)" fill="#ebebeb" stroke="#707070" stroke-width="1">
        <circle cx="99.5" cy="99.5" r="99.5"/><circle cx="99.5" cy="99.5" r="99" fill="none"/>
      </g>
      <g transform="translate(949 141)" fill="#ebebeb" stroke="#707070" stroke-width="1">
        <circle cx="96.5" cy="96.5" r="96.5"/><circle cx="96.5" cy="96.5" r="96" fill="none"/>
      </g>
      <g transform="translate(1036 228)" fill="#ebebeb" stroke="#707070" stroke-width="1">
        <circle cx="9.5" cy="9.5" r="9.5"/><circle cx="9.5" cy="9.5" r="9" fill="none"/>
      </g>
      <g transform="translate(1095 167)" fill="#ebebeb" stroke="#707070" stroke-width="1">
        <circle cx="5.5" cy="5.5" r="5.5"/><circle cx="5.5" cy="5.5" r="5" fill="none"/>
      </g>
      <text transform="translate(1017 289)" fill="#707070" font-size="20" font-family="HelveticaNeue, Helvetica Neue">Track</text>
    </g>
  </g>
</svg>`;

/* ============================
   Create 3 cassette DOMs (positions match your screenshot)
   ============================ */
const initialPositions = [
  {left: 20, top: 8},    // top-left (Track1)
  {left: 180, top: 8},   // top-right (Track2)
  {left: 100, top: 210}  // bottom-center (Track3)
];
for(let i=0;i<3;i++) createCassette('cass'+(i+1), i, initialPositions[i]);

function createCassette(id, trackIndex, pos){
  const wrapper = document.createElement('div');
  wrapper.className = 'cassette';
  wrapper.dataset.cid = id;
  wrapper.dataset.track = trackIndex;
  wrapper.style.left = pos.left + 'px';
  wrapper.style.top  = pos.top + 'px';
  wrapper.innerHTML = CASSETTE_SVG;
  tokensGrid.appendChild(wrapper);
  cassetteState[id] = { trackIndex, el:wrapper, onPad:false, cached:false, playing:false, queued:false };
  makeDraggable(wrapper);
}

/* ============================
   Drag/magnet/drop behaviour
   ============================ */
function getPadRectScreen(){
  const padBox = padRectEl.getBBox();
  const svgRect = playerSVG.getBoundingClientRect();
  const viewBox = playerSVG.viewBox.baseVal;
  const scaleX = svgRect.width / viewBox.width;
  const scaleY = svgRect.height / viewBox.height;
  const left = svgRect.left + padBox.x * scaleX;
  const top  = svgRect.top  + padBox.y * scaleY;
  return { left, top, width: padBox.width * scaleX, height: padBox.height * scaleY, centerX:left + (padBox.x + padBox.width/2)*scaleX, centerY: top + (padBox.y + padBox.height/2)*scaleY };
}

function makeDraggable(elem){
  let dragging=false, pointerId=null, offset={x:0,y:0};
  const id = elem.dataset.cid;

  function onPointerDown(e){
    e.preventDefault();
    dragging=true; pointerId = e.pointerId;
    elem.classList.add('dragging');
    const r = elem.getBoundingClientRect();
    offset.x = e.clientX - r.left; offset.y = e.clientY - r.top;
    // lift behavior: if playing -> stop
    const st = cassetteState[id];
    if (st.playing) stopCassette(id, true);
    elem.setPointerCapture(pointerId);
  }
  function onPointerMove(e){
    if(!dragging || e.pointerId !== pointerId) return;
    let nx = e.clientX - offset.x;
    let ny = e.clientY - offset.y;

    const pad = getPadRectScreen();
    const dx = e.clientX - pad.centerX, dy = e.clientY - pad.centerY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const magnetRadius = Math.max(pad.width, pad.height) * 0.75;
    if (dist < magnetRadius){
      const pull = 0.12 + (1 - dist/magnetRadius)*0.25;
      nx = nx + (pad.centerX - e.clientX)*pull;
      ny = ny + (pad.centerY - e.clientY)*pull;
      elem.style.transform = 'scale(1.02)';
    } else elem.style.transform = '';

    const stageRect = document.getElementById('stage').getBoundingClientRect();
    nx = Math.max(stageRect.left - 6, Math.min(nx, stageRect.right - elem.offsetWidth + 6));
    ny = Math.max(stageRect.top - 6, Math.min(ny, stageRect.bottom - elem.offsetHeight + 6));

    elem.style.left = (nx - tokensGrid.getBoundingClientRect().left) + 'px';
    elem.style.top  = (ny - tokensGrid.getBoundingClientRect().top) + 'px';

    const inside = (e.clientX >= pad.left && e.clientX <= pad.left + pad.width && e.clientY >= pad.top && e.clientY <= pad.top + pad.height);
    if (inside) elem.style.boxShadow = '0 34px 80px rgba(0,0,0,0.7), 0 0 30px rgba(30,140,220,0.06)';
    else elem.style.boxShadow = '0 18px 40px rgba(0,0,0,0.6)';
  }
  function onPointerUp(e){
    if(!dragging || e.pointerId !== pointerId) return;
    dragging=false; elem.classList.remove('dragging'); elem.releasePointerCapture(pointerId); elem.style.transform='';
    const rect = elem.getBoundingClientRect();
    const centerX = rect.left + rect.width/2;
    const centerY = rect.top + rect.height/2;
    const pad = getPadRectScreen();
    const inside = (centerX >= pad.left && centerX <= pad.left + pad.width && centerY >= pad.top && centerY <= pad.top + pad.height);
    if (inside){
      const container = tokensGrid.getBoundingClientRect();
      const snapX = Math.max(pad.left + 12, Math.min(centerX, pad.left + pad.width - 12));
      const snapY = Math.max(pad.top + 12, Math.min(centerY, pad.top + pad.height - 12));
      elem.style.left = (snapX - container.left - rect.width/2) + 'px';
      elem.style.top  = (snapY - container.top - rect.height/2) + 'px';
      cassetteState[id].onPad = true;
      if (!cassetteState[id].cached){
        showLoading(true);
        setTimeout(()=>{ cassetteState[id].cached = true; showLoading(false); handleDrop(id); }, 700 + Math.random()*700);
      } else handleDrop(id);
    } else {
      if (cassetteState[id].onPad){
        cassetteState[id].onPad = false;
        removeFromQueue(id);
        if (cassetteState[id].playing){
          stopCassette(id, false);
          startNextInQueue();
        }
      }
    }
  }

  elem.addEventListener('pointerdown', onPointerDown);
  window.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);
}

/* ============================
   Helpers: loading badge
   ============================ */
function showLoading(on){ loadingBadge.style.display = on ? 'flex' : 'none'; }

/* ============================
   Drop handling: start or queue
   ============================ */
function handleDrop(cid){
  const st = cassetteState[cid];
  if (!powerOn) { showLoading(true); setTimeout(()=>showLoading(false),500); return; }
  if (!currentPlayingId){
    startCassette(cid);
  } else {
    if (!st.queued){
      st.queued = true; playQueue.push(cid); updateQueueView();
    }
  }
  updateCassetteUI(cid);
}

/* ============================
   Start/stop cassette playback
   ============================ */
function startCassette(cid){
  if (!powerOn) { showLoading(true); setTimeout(()=>showLoading(false),500); return; }
  const st = cassetteState[cid]; if(!st) return;
  const idx = st.trackIndex; const aud = audioEls[idx];
  if (aud && aud.src){
    aud.volume = masterVolume;
    aud.currentTime = 0;
    aud.play().catch(e=>console.warn('Audio play err', e));
    aud.onended = ()=>{ st.playing=false; currentPlayingId=null; startNextInQueue(); updateCassetteUI(cid); };
  } else {
    setTimeout(()=>{ st.playing=false; currentPlayingId=null; startNextInQueue(); updateCassetteUI(cid); }, 8000 + Math.random()*4000);
  }
  st.playing = true; currentPlayingId = cid;
  if (st.queued){ st.queued=false; playQueue = playQueue.filter(x=>x!==cid); }
  updateQueueView(); updateCassetteUI(cid);
}

function stopCassette(cid, dueToLift){
  const st = cassetteState[cid]; if(!st) return;
  const idx = st.trackIndex; const aud = audioEls[idx];
  if (aud && !aud.paused){ try{ aud.pause(); aud.currentTime=0; }catch(e){} }
  st.playing=false; if (currentPlayingId===cid) currentPlayingId=null;
  if (st.queued){ st.queued=false; playQueue = playQueue.filter(x=>x!==cid); }
  updateQueueView(); updateCassetteUI(cid);
}

/* ============================
   Queue logic
   ============================ */
function startNextInQueue(){
  if (currentPlayingId) return;
  if (shuffleOn && playQueue.length>1){
    // pick a random one from queue
    const idx = Math.floor(Math.random()*playQueue.length);
    const next = playQueue.splice(idx,1)[0];
    startCassette(next);
    return;
  }
  while (playQueue.length){
    const next = playQueue.shift();
    const st = cassetteState[next];
    if (st && st.onPad) { startCassette(next); return; }
  }
  updateQueueView();
}
function removeFromQueue(cid){ playQueue = playQueue.filter(x=>x!==cid); if (cassetteState[cid]) cassetteState[cid].queued=false; updateQueueView(); }

/* ============================
   UI updates
   ============================ */
function updateQueueView(){
  if (!currentPlayingId && playQueue.length===0){ queueView.textContent='Ingen kö'; return; }
  let out='';
  if (currentPlayingId){ out += `Spelar nu: Cassette ${cassetteState[currentPlayingId].trackIndex+1}\n`; }
  if (playQueue.length){ out += '\nKö:\n'; playQueue.forEach((c,i)=> out += `${i+1}. Cassette ${cassetteState[c].trackIndex+1}\n`); }
  queueView.textContent = out;
}
function updateCassetteUI(cid){
  const st = cassetteState[cid]; if(!st) return;
  const el = st.el;
  if (st.playing) el.style.outline = '3px solid rgba(40,200,220,0.9)';
  else if (st.queued) el.style.outline = '2px dashed rgba(200,200,200,0.15)';
  else if (st.onPad && st.cached) el.style.outline = '1px solid rgba(255,255,255,0.03)';
  else el.style.outline = 'none';
}

/* ============================
   Volume controls (master)
   ============================ */
function setMasterVolume(v){
  masterVolume = Math.max(0, Math.min(1, v));
  for (let i=0;i<audioEls.length;i++){
    if (audioEls[i] && !audioEls[i].paused) audioEls[i].volume = masterVolume;
  }
}
function changeMaster(d){
  setMasterVolume(masterVolume + d);
}

/* ============================
   Button animation helper
   ============================ */
function tapAnimate(el){
  if (!el) return;
  el.style.transition = 'transform 110ms cubic-bezier(.2,.9,.3,1)';
  el.style.transform = 'scale(0.9)';
  setTimeout(()=> el.style.transform = '', 140);
}

/* ============================
   Button wiring (power/shuffle/vol)
   ============================ */
function unlockAudioOnce(){
  if (audioUnlocked) return Promise.resolve();
  audioUnlocked = true;
  // try play/pause each audio to satisfy gesture policy
  return Promise.all(audioEls.map(a=>{
    if (!a || !a.src) return Promise.resolve();
    return a.play().then(()=>{ a.pause(); a.currentTime = 0; }).catch(()=>{});
  })).then(()=>{ console.log('Audio unlocked'); });
}

if (powerBtnSvg){
  powerBtnSvg.addEventListener('click', async (e)=>{
    tapAnimate(powerBtnSvg);
    await unlockAudioOnce();
    powerOn = !powerOn;
    powerStateLabel.textContent = 'Power: ' + (powerOn ? 'On' : 'Off');
    powerBtnSvg.classList.toggle('btn-active-outline', powerOn);
    if (!powerOn){
      // stop all
      for (let a of audioEls){ try{ a.pause(); a.currentTime = 0; }catch(e){} }
      playQueue = []; currentPlayingId = null;
      Object.keys(cassetteState).forEach(k=>{ cassetteState[k].playing=false; cassetteState[k].queued=false; updateCassetteUI(k); });
      updateQueueView();
    } else {
      // if there is a queued item, try start next
      startNextInQueue();
    }
  });
}

if (shuffleBtn){
  shuffleBtn.addEventListener('click', (e)=>{
    tapAnimate(shuffleBtn);
    shuffleOn = !shuffleOn;
    shuffleBtn.classList.toggle('btn-active-outline', shuffleOn);
  });
}
if (volDownBtn) volDownBtn.addEventListener('click', (e)=>{ tapAnimate(volDownBtn); changeMaster(-0.06); });
if (volUpBtn) volUpBtn.addEventListener('click', (e)=>{ tapAnimate(volUpBtn); changeMaster(0.06); });

/* ============================
   Stop all & reset (exposed controls)
   ============================ */
document.addEventListener('keydown', (e)=>{ if (e.key === ' '){ document.getElementById('stopAll')?.click?.(); } });

/* ============================
   Stop all / Reset buttons (if present)
   ============================ */
// create small stop/reset controls behind the scenes (optional)
const stopAllBtn = document.createElement('button'); stopAllBtn.id='stopAll'; stopAllBtn.style.display='none'; document.body.appendChild(stopAllBtn);
stopAllBtn.addEventListener('click', ()=>{ for (let a of audioEls){ try{ a.pause(); a.currentTime=0; }catch(e){} } Object.keys(cassetteState).forEach(k=>{ cassetteState[k].playing=false; cassetteState[k].queued=false; cassetteState[k].onPad=false; updateCassetteUI(k); }); currentPlayingId=null; playQueue=[]; updateQueueView(); });

const resetBtn = document.createElement('button'); resetBtn.id='resetPositions'; resetBtn.style.display='none'; document.body.appendChild(resetBtn);
resetBtn.addEventListener('click', ()=>{ const keys = Object.keys(cassetteState); for (let i=0;i<keys.length;i++){ const k = keys[i]; cassetteState[k].el.style.left = initialPositions[i].left + 'px'; cassetteState[k].el.style.top = initialPositions[i].top + 'px'; } stopAllBtn.click(); });

/* ============================
   Initial UI refresh
   ============================ */
Object.keys(cassetteState).forEach(k=>updateCassetteUI(k));
updateQueueView();

console.log('CUBE player ready (buttons integrated).');
</script>
</body>
</html>
